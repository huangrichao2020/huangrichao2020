# 1 线性表
### 如何自定义
    typedef struct{ }SeQuene;//自定义结构体(类)
    SeQuene *sq;
    
### 设计数据结构时什么叫需考虑
    需考虑的一般是特殊情况,不考虑这些的话,极大概率会出错.
### 必会概念:
	链式存储 前驱 后继 表长
### 超级技巧
    凡涉及到"走",都要用赋值.
### 链表的本质:
LinkList L; L = create_LinkList(10);
**此时L看起来是一个线性表,其实它本质只是一个节点的引用,指向线性表表头节点.通过这个引用我们可以遍历整张线性表**
## 1.1数据结构如何应用到运算
> 逻辑结构定义算法,存储结构运行算法

**线性表常用逻辑算法:**
1. **初始化**:Init_List(L) 构造一个空表
2. **求表长**:Length_List(L) 返回表含有的元素的个数
3. **取表元**:Get_List(L,i)  L非空,i正确时,返回地i个表元的值或地址
4. **查找(定位)**:已知值,查下标. Locate_List(L,x)  返回x在L中首次出现的序号或地址,否则返回-1
5. **插入**:Insert_List(L,i,x) L存在,i正确.是L[i]=x; L.len()++; L[i]之后的表元下标依次加一
6. **删除**: Delete_List(L,i) L存在,i正确时 L[i] = L[i+1] ;L.len()-- ;L[i]之后的表元下标依次减一

## 1.2 顺序表
> 列表在内存中按连续物理地址存储,知道了地址就一定能访问到对应的元素


**优点与好处**
1. 已知表头地址Loc(`$a_0$`),表元类型(所占字节) d比特,则瞬间可求第(i+1)个元素的地址.Loc(`$a_i$`)=Loc(`$a_0$`)+i*d  , 0≤i≤n
2. 所以顺序存储用来查找,访问,修改元素非常方便

## 1.3 顺序表的实现
> 距离是元素间相距长度,个数是下标相减再加1.

>Capacity(L) = L.MAXSIZE ;下标n必须时刻≤MAXSIZE ;设插入下标为i,最末下标为n; i必须时刻≤n+1;
#### 1.3.1 动态初始化
1. 构造一个空表.
2. 动态分配存储空间,先确定表容量,但具体地址对应的表元在后续代码里确定
3. 定义表指针last=-1,随L.len()增加而增加
### 1.3.2 插入运算
1. 用for循环实现:j=n+1 从`$L(n)$`起,元素依次向后挪动一位.`$L(j)$` = `$L(j-1)$`;  j--;
2. 插入x: L(i) = x;
3. 修改表尾指针:L.last = L.len()++;
4. 算法复杂度计算: 主要耗时都发生在元素移动时.每次移动(n-i+1)个元素,即移动(n-i+1)次,假设插入到底i个元素是等概率事件,则对应的概率`$P_i$`=1/(n+1).
5. 总移动次数 = `$\sum_{i=1}^{n+1}=P_i(n-i+1)=\frac{n}{2}$`,即时间复杂度是O(n)

### 1.3.3 删除操作
1. 0≤i≤n,否则报错,已经包含了i=-1,L为null时的情景.
2. for循环实现:j=;j≤n;从L[i]起,L[j] = L[j+1];j++;
3. 算法复杂度:O(n)

### 1.3.4 查找操作
> 找列表中值为x的第一个元素下标
1. for循环,j=0; L[j]==x ; 否则j++;
2. 若j==n,返回"无"
3. 算法复杂度:$\sum_{i=0}^nP_ii=\frac{n+1}{2}=O(n)$`

## 1.4 线性表的链式存储与运算实现
### 1.4.1 先修知识
#### 1.4.1.1 malloc与new的区别
new会自动根据类型分配内存地址,并返回同类型的指针给引用
```
int *p1,*p2;
p1 = new int;
p2 = new int[100];
```
malloc只能动态分配内存,意思就是不会自动分配,必须人为设定内存大小与返回的指针类型
```
int *p;
p = (int*)malloc(sizeof(int)*100);

```
#### 1.4.1.2 ->的用法
->是间接引用符,是二目访问符,类似于成员符 .
```c
typedef struct Node{
    int a;
    double b;
}node, *linkList;
*linkList = &node;
//struct Node *p = &node;
//此时
linkList->a等价于(*linkList).a;
```
#### 1.4.1.3 struct的用法
自定义类型struct
```
typedef struct Node{
    Elemtype a;
    Node *next;
}node,linkList; //结构变量node等有点像静态类,这里借用java编程思想描述,Node是父类,node,linkList是子类.
或
struct Node node,linkList;//按模板类型Node定义具体类型node,linkList
```
写一个struct Node,编译器只是读取它,并不会为它赋予内存空间.逻辑合理,它只是一个模板.
### 1.4.2 节点
> 节点由数据域和指针域构成.指针域决定先后链接顺序,有时链接关系不好修改的,可以直接交换数据域的内容,间接达到交换节点的目的.

单链表由一个个节点构成
```c
typedef struct node{
    datatype data;
    struct node *next;
}LNode

node LNode = {};
```
等价于
```java
public class node{
    Object data;
    class node next;
}
public class LNode extends node{}
```
### 1.4.3 栈
> 后进先出,前插法 

> 抽象:表L; 新节点s(malloc,s->a=x); s->next=L(指向表头);L=s(表头指向s,s再指向next里保存的旧表头地址)
```c
    linkList create_stack(int flag){
        linkList L = null; //linkList是指针子类,故L也是指针,又L=null静态声明,省去了malloc分配.
        // 同时! L==null;第一个节点s->next=L,巧妙地使最后一个节点的next为null.不会出现野指针.
        node *s;
        int x;
        scanf("%d",&x);
        int cout=1;
        while(cout<=flag){
            s=(Node*)malloc(sizeof(node));//每次循环都会手动new一个s.因为新的s节点的next后继是上一节点,所以新的s节点是上一节点的前驱.即新的s节点是前插的.满足栈后进先出的形式.
            s->data=x;
            s->next=L;//s上链指向L的表头,此时s还不算在L内
            L = s;//让s做L的表头,即巧妙地让L永远指向新的表头元素.
            scanf("%d",&x);
            cout++;
        }
        return L;
    }
```



### 1.4.4 队列
> 后进后出,尾插法

> 表L只要指向表头就够了,我们可以用副表指针*r先指向第一个节点(s作表头时),它与L都是指向第一个节点的引用.
```c
linkList create_quene(int flag){
    linkList L=null;
    node *s,*r=null;
    int x;
    scanf("%d",&x);
    int cout=1;
    while(cout<=flag){
        s = malloc(sizeof(node)); //new一个s,new完对s的属性赋值
        s->a = x; 
        if(L=null) L=s;
        else r->next = s;上链
        r = s; //此处r,L都是s的软引用.L占了r的光,之后一条龙的链表全靠r接上.L最多指向表头,其余上链操作有r来完成
        scanf("%d",&x);
        cout++;
    }
    //定义表尾节点的后继节点为空.
}
```
### 1.4.5 利用表指针求表长
> 表指针顺节点往下走(赋值),表指针都是数据域为空,指针域指向当前节点,与节点同类型的内存空间.

> 后插法里的L,*r都是表指针,其中L作头指针变量,它所引用的节点叫头节点.即L是头节点,L->next才是第一个数据节点
```
int linkList_length(linkList L){
    node *p = L;
    int j=0;
    while(p->next!=nuLl){
        p=p->next;
        j++;
    }
    return j;
}

```
### 1.4.6 前插法与后插法
> *p指向某个节点,*s指向待插入的新节点
```
graph LR
后插法
A(节点p)-->|起初令p->next=p',得到|B(p的下一节点是p')
A-->|最终p的下一节点是s|C
C-->|第二步p->next=s|A
C(待插入节点s)-->|第一步s->next=p`|B
```
```
graph BT
前插法
B(当前节点p)-->|第一步 q=L, while \q->next!=p\ q=q->next|A(找到p的前驱q)
C-->|第二步 s->next=p|B
A-->|第三步 q->next=s|C
C(待插入节点s)
```
```
graph TB
后插+交换实现前插
A(节点p)-->|起初 p->next=p`|B(p的下一节点是p`)
A-->|交换节点数据swap\p->next,s->next\|C
C-->|第二步p->next=s|A
C(待插入节点s)-->|第一步s->next=p`|B
```
### 1.4.7 删除节点
> 当前节点*p,前驱节点*q
1. 已知*p,找到它的前驱*q
2. *q->next = *p->next
3. free(p)
### 1.4.8 删除当前节点的后一节点
> 当前节点*p
1. node *s;
2. s = p->next;
3. p->next = s->next;
4. free(s);
### 1.4.9 删除表L的第i个元素
1. for循环找到L[i-1]
2. 若L[i-1]->next != null
3. 则用删除节点法,删除第i个节点

### 1.4.10 单循环列表
1. 尾指针指向头指针
2. 判断表已经遍历一遍的方法是p->next == head,是则已到尾指针.
3. 有时可用r指向尾指针,直接从尾部开始遍历,加快运算.
## 1.4.11 单链表总结
    单链表不具备按序号随机(直接)访问元素的能力,必须先找到它的前驱节点,才能访问要访问的节点.即只能从头指针开始访问.

## 1.5 双向链表
<table>
    <th>prior</th>
    <th>data</th>
    <th>next</th>
</table>

```c
typedef struct dlnode{
    datatype data;
    struct dlnode *prior,*next;
}DLnode,*DLinkList
```
**单链表能做的事它都能做,最大的区别就是每修改一次链表,必须前后节点都要定义指向一次**

### 1.5.1 插入
> 已知p,插入s
s->prior = p->prior;
p->prior->next = s;
p->prior = s;
s->next = p;

### 1.5.2 删除(free)
> 已知p,删除p

1. p->prior->next = p->next;
2. p->next->prior = p->prior;
3. free(p);

## 1.6 以a1为基准,划分线性表
> 划分就是重排列,比a1小的在前,大的在后

## 1.7 两线性表比较大小
> A长a,B长b,两数组第一次不同时的下标i,A的剩余长度as,B的剩余长度bs,
1. for循环使下标走到两数组第一次不同的地方,i
2. for(j=i;j<a;j++){ AS[j-i]=A[j];a++;}
3. for(j=i;j<b;j++){ BS[j-i]=B[j];b++;}
4. if(as==bs&&as==0) return 0;//A==B
5. if(as==0&&bs>0 || as>0&&bs>0&&AS[0]<BS[0]) return -1;//A<B
6. else return 1;//A>B

## 1.8 倒转单链表
> 将原链表H中的每一个元素依次作为第一个元素插入到新链表中
void reverse(LinkList H){
    Node *p;
    p=H->next;
    while(p){
        q=p;
        p=p->next;
        //插入q到头节点后面
        q->next = H->next;
        H->next = q;
    }
}

## 1.9 删除表L中重复的元素
> 从首元素开始,遍历表L,删除与首元素相同的元素(修改链接关系),类推

**两层遍历,两层while**
```c
void pur_LinkList(LinkList H){
    Node *p,*q,*r;
    p=H->next;
    while(p->next){
        q=p;
        while(q->next){
            if(q->next->data=p->next){
                r = q->next;
                q->next=r->next;
                free(r);
        }else{
            q=q->next;//下一个对比元素
        }
        p=p->next;//下一个首元素
    }
}
```
## 1.10 按访问权比排序链表元素
> prior前驱指针域,data数据域,next后继指针域,freq权比域,每访问一次值为x的元素,增加它的权比,并按大到小排序.

```c
void LocateNode(LinkList L,DataType x){
    ListNode *p,*q;
    p=L->next;
    q=L->next;
    while(p){
        if(p->data!=x) p=p->next;
        else{
            p->freq++;
            break;
        }
        while(q){
            if(q->freq > p->freq) q=q->next;
            else{
                p->prior->next=p->next;//摘下当前节点
                p->prior = q->prior;//开始插入
                q->prior->next=p;
                p->next=q;
                q->prior=p;
            }
        }
    }
}
```
### 1.11 思考
1. 针对表尾添加或删除节点的操作,用带头结点的双循环列表最高效.
2. 在遍历输出链表数据时，带头结点的判断条件是while(head->next!=NULL)，而不带头结点是while(head!=NULL)
3. 顺序表,访问复杂度为O(1),增删复杂度为O(n)
4. 同时遍历长度分别为m,n的表,算法复杂度O(n)=m+n;
5. 模式匹配.

# 2.栈
## 2.1 栈定义及基本运算
> 只允许在栈顶插入或删除的线性表,栈底固定.表null则是空栈

1. 初始化:Init_Stack(s)
2. 判空栈:Empty_Stack(s)
3. 入栈:Push_Stack(s,x)
4. 出栈:Pop_Stack(s)
5. 读取栈顶:Top_Stack(s)

## 2.2 栈的存储实现与运算实现
### 2.2.1 定义顺序栈
> 栈是线性表的一种,所以定义一个顺序栈就是定义一个带指针的有长度的表
```c
#define MAXSIZE 1024
typedef struct{
    datatype data[MAXSIZe];
    int top;
}SeqStack
SeqStack *s;
```
通常空栈时top=-1,入栈时s->top++;出栈时,s->top--;
**可知表尾是栈顶,表头是栈底**

### 2.2.2 置空栈
```c
SeqStack *Init_SeqStack(){
    SeqStack *s;
    s = malloc(size(SeqStack));
    s->top=-1;
    return s;
}
```
### 2.2.3 判空
int Empty_Stack(SeqStack *s){
    if(s->top==-1) return 1;
    else return 0;
}
### 2.2.4 入栈
> 需考虑栈满

int Push_SeqStack(SeqStack *s,datatype x){
    if(s->top==MAXSIZE-1) return 0;//0表示什么都不做,原因可能是已经满了,无法做
    else{
        s->top++;
        s->data[s->top]=x;
        return 1;
    }
}
### 2.2.5 出栈
int Pop_SeqStack(SeqStack *s,datatype *x){
    if(Empty_SeqStack(s)) return 0;
    else{
        *x = s->data[s->top];//将栈顶数据赋给
        s->top--; //调整top指针,原栈顶无指针指向它,成了一个浪费内存的元素.
        return 1;
    }
}
### 2.2.6 取栈顶
> 需考虑栈空

datatype Top_SeqStack(SeqStack *s){
    if(Empty_SeqStack(s)) return 0;
    else return(s->data[s->top])
}
## 3 队列
### 3.1 队列的定义
> 先进先出的线性表,front队头,rear队尾,双指针
```c
define MAXSIZE 1024
typedef srtuct
{
    datatype data[MAXSIZE];
    int rear,front;
}SeqQuene;

SeQuene *sq;//声明引用

sq = malloc(sizeof(SeQuene));//申请内存空间

sq->data[0]到sq->data[MAXSIZE-1];
sq->front;
sq->rear;

```
