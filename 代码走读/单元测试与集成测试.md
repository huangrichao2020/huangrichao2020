
## Demo梳理
AS换页：ctrl+tab 
### release11demo
MainActivity进去，先Constant.initCase();目的是初始化一些列按钮用于跳转
不同的测试页面。


## 获取activity
系统方法一般有context实参,
WeakReference<Activity> weak; // 定义弱引用变量
public Adapter(Context context){
this.weak = new WeakReference<Activity>((Activity)context);
   ........
}
getView(){
  this.weak = new WekReference<Activity>((Activity)context)
}


### 运行指令
 - spy 真实函数运行时监视器wrap 运行次数 输入参数 返回结果
   - obj 与 Mockito.spy(obj)之间的区别
 - stub 上层假函数 可定义输入与输出
 - mock 对象模拟，监视+假函数

### 单测分类
- XxxTest 测试类
- testXxx 测试方法
- Local tests 纯JVM环境 或 Mockito轻模拟框架
- Instrumented tests 真机或模拟器，可获取App上下文信息

### Junit注解
@Test 定义单测测试方法
@Test(expected = Exception.class) 方法必须抛出Exception
@Test(timeout=100) 性能测试，耗时不可超过100ms
@Before 每个Test方法触发一次。初始化，读输入流
@After 每个Test方法触发一次，清理数据
@BeforeClass public static void method()
@AfterClass public static void method()
@Ignore("太耗时")
@FixMethodOrder(MethodSorters.NAME_ASCENDING) public class TestClass{}
@Rule 注解修饰固定几个对象或功能，类内所有test方法共享@Rule定义的东西。
@RunWith(Parameterized.class) 参数化，Test类初始化一些参数，与构造方法。再用 ```  @Parameters
        public static Collection<Object[]> initTestData(){return Arrays.asList(new Object[][] {
            {"hello:world", "world"},
            {"hello:!@#$%^&*()_+", "!@#$%^&*()_+"}
        }```

  会自动利用@Parameters修饰的方法返回的结合里的数据作为实参，循环创建测试类的实例。

### Jacoco基本概念
- 行覆盖，需要类文件携带debug信息编译
  - 红色 未覆盖
  - 黄色 部分覆盖
  - 绿色 全覆盖

- 类覆盖
  - 构造函数，静态初始化方法，普通方法其中之一执行过就是已执行类



## 自动化测试
- 判断load成功
- 执行关闭方法  shouldOverrideUrlLoading
- 根据回调判断 是否成功。

## espresso文档
[esoresso教程](https://www.jianshu.com/p/94e66dcb22b1)
- demo地址 https://github.com/huangrichao2019/growingio-sdk-android-autotracker.git 
- auto-test分支 demos/demo里的andoridTest
**用espresso测试网络问题**

- counter标志符需要考虑并发问题，一般建议使用 AtomicInteger
- 所谓callback接口的回调就是if(xxx) 执行以下接口里的空方法，比如resourceCallback.onTransitionToIdle();有执行就行了，不用管方法有没有内容。
## pr提交规范
      
## ci接入流程
[travis持续构建](https://www.cnblogs.com/blackpuppy/p/use_travis_to_build_and_deploy.html)


## 3.0自动化

### 重写AndoridJunitRunner
安卓专业测试用例运行期：TestRunner将测试软件包与应用添加到设备，运行测试并生成结果
- 重写Instrumentation.newApplication 将Application对象实例化，
- 

### 自定义TestMessageHandler
- 初始化方法里重写并发双向队列ConcurrentLinkedDeque的add方法,形参为Message，专门处理捕获到的msg对象.
- super.add()
- 根据mgs.what标号从SparseArray里获取对应的TestMessageHandler静态整数字段名。字符串后续拼接msg.obj数组里的每一个对象为String result。
- REVERSE_MAP.put(字段值, 字段名);
- 创建一个名为gio_msg.txt的stream，stream写入result
- 建一个数组列表filteredMessageQueues，内容为Pair<Deque<Message>, [0x100000]>
- 




### new Handler的内存泄漏风险
- new Handler()内存泄漏风险
- new Handler(Handler.Callbacks(){匿名xxx} ) handler对象会一直持有匿名内部对象的引用，匿名对象里若果持有了外部对象的引用的话gc可能无法回收handler。需要手动在onDestroy周期内执行handler.removeCallbacksAndMessages(null);
- new Handler(new WeakReference<Handler.Callbacks>(new Handler.Callback(){xxx}));



## 引用的分类
- 强引用：new出来的叫强引用，超出作用域或引用赋值为null时GC才会回收。


### @Parameters参数化设定
```
@Parameters//创建并返回测试数据
public static Collection params() {
    return Arrays.asList(new Integer[][] { { 3, 1, 2 }, { 5, 2, 3 } });
}

 //在测试类的初始化方法里接收并存储（实例化）测试数据
    public FirstTest(int expected, int a, int b) {
        this.expected = expected;
        this.a = a;
        this.b = b;
    }

@Test//轮番使用测试数据测试

```

@Test(timeout=1000) 用例1000毫秒内执行完的话则通过

@Test(expected = NullPointerException.class) 异常测试 ，预期代码出现NullPointerException异常。

## 关于模块，继承，依赖范围测试
教程：https://www.jianshu.com/p/5c971ecdaf6e

compile,test,provided 这三种不同的scope决定了模块与模块之间，项目与项目之间jar包依赖的传递性的不同。

父子
- 父模块的所有包可以被子模块使用
兄弟
- 弟弟依赖哥哥，可以使用哥哥模块的所有compile依赖，用不了哥哥的test与compile依赖