## 分时操作系统


## 操作系统的启动过程


### REALMODE 实模式

CPU单任务启动，访问0h-FFFFFh 1024KB的空间

- 前640K 基本内存
- 中128k 显卡显存
- 末256k BIOS:Basic I/O System 以硬件形式存储的固件
  - F0000-FFFFF
  - 基本输入/输出 利用中断实现，如INT 13H:AH=02：13号扇区中断02号入口
  - 系统启动配置 CMOS
  - 系统加电自检 POST:Power On Self-Test
  

### PowerOn后的第一条指令
    内存FFFF0h处-->JUMP POST

POST之后
- 查找显卡BIOS
- 其他设备BIOS
- 线上启动画面，BIOS信息，芯片主板信息等
- 根据CMOS设置
- 从硬盘/光驱/U盘 读取OS内核
- OS接管计算机

### BIOS读硬盘的过程
MBR（MAIN BOOT RECORD 主启动记录）
- 首扇区:主启动扇区
  - 提供菜单启动项
  - 跳转LOADER
- 512B
- 0xAA55h
- 首扇区以外的叫分区启动扇区

### 总过程
PowerOn-->JUMP POST-->
POST(BIOS)--设备启动,屏幕可输入-->
CMOS--硬盘启动-->读取MBR--加载引导程序-->
读取分区表PT--找到活动分区AT-->
读取分区引导记录PBR-->加载OS内核

PBR加载到内存后，控制后续的引导过程，根据参数初始化OS内核

### OS初始化

POST-->MBR-->读取KERNEL zlib映像-->边解压边执行硬件初始化-->内核初始化-->内核启动

KERNEL-->init进程 PID=1-->/etc/inittab脚本完成设备初始化

### 用户界面
用户接口=操作界面+系统调用

shell命令
- ~/.bash_history 
- history -c
- >>追加输出重定向
- < 输入重定向
- 2> errfile.log 错误日志重定向
- 管道 | 将左边的输出作为右边的输入

```bash
#!/bin/bash
sudo mkdir /usr/temp
sudo echo "正在解压文件"
sudo unzip -qd /usr/temp /HUST.zip
sudo echo "解压完成"

sudo cp -rf /usr/temp/HUST usr/lib
sudo ldconfig
sudo echo "正在删除临时文件"
sudo rm -rf /usr/temp
sudo echo "安装完成请重启"
```

### 系统调用的中断过程
用户程序调用系统功能

应用程序-->CALL X号功能-->保护应用程序现场-->
根据编号X查X号系统功能的入口地址-->系统调用X号功能

- DOS系统里通过INT 21H 号中断可以实现多种系统调用
- Linux利用INT 80H 中断实现系统调用
```
printf("Hello World!");
=======
MSG:DB "Hello World!"
MOV EBX,1 //送入stdou的t编号
MOV ECX,MSG //送入首地址
MOV EDX,14 //送入字符串长度
MOV EAX,4 //指定系统调用的编号
INT 80h   //引发80号中断：输出字符串
```

## 进程/线程/锁

    并发分时操作系统的弊端
全局变量i，在两个程序中被赋予不同的值，结果不可控，谁也不知道程序A先赋值还是程序B先赋值。
    
    为了解决上述问题，引入进程做程序间约束
进程就是某个数据集合的一次活动。
- 动态
- 并发，一起活动
- 异步，进度各自不同，照样能占用CPU.
- 独立性,进程是系统分配CPU的单位。

    进程与程序的区别
- 类似对象与类
- 进程是一组执行过程，在内存中暂存
- 程序是一组指令集合，在硬盘上长期保留
- 大白话讲，run起来的叫进程，没run起来的叫程序

    进程的状态
- 断断续续
- 与其他进程共享CPU
- 频繁IO时，断断续续更明显

[Running,Ready,Block/Wait]:[运行状态占有CPU,就绪状态无CPU,阻塞状态等待运行信号]

就绪-->运行：进程调度
运行-->就绪：时间片到 、 被抢占
运行-->阻塞：请求新服务，等待信号
阻塞-->就绪：调度服务完成，信号来到

可运行

