> 标签的本质是写一个RESTful接口共外部系统调用
## 建议Chrome浏览器知识
1. Payload:一个post请求报文里,有效载荷/报文算上协议的总长的比重. 
2. 
## 项目生产环境配置
> mac系统环境
    
    ~/.bash_profile 或 /etc/local/profile
    1. /etc/local里的配置是所有用户可用的,~是当前用户
    2. .bash_profil作用是配置系统环境,
    3. .bashrc作用是shell bash脚本配置
    4. .bash_logout是用户shell推出清理命令脚本
    5. 修改文件后暂时用source重启

1. maven放在 ~/.java/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;版本:3.5.4
2. 查看系统变量echo $PATH
3. 查看mvn环境echo $M2_HOME
4. 中金易云项目放在 ~/zjyy/
5. edas ~/edas-center-config
6. edas配置 ~/.m2/repository
7. 用mvn下载为项目下载依赖mvn help:effective-settings
8. edas配置中心参考 http://47.100.111.124:8080/#/serviceList/publisher
9. 中金易云 后端登入http://47.100.111.124:8001/
18812341234   abc123
10. 中金易云效果 http://47.100.111.124/login
11. 公司edas配置地址 http://47.100.111.124:8080/#/serviceList/publisher
12. 我的edashttp://127.0.0.1:8080/#/dsConfig
13. 中金易云账号密码 13071893593 abc123 888
14. 公司conference项目地址 Confluece:http://confluence.dev.dtstack.cn
账号：tingchi
密码：huang.123581321 


## 项目整体代码配置
### Maven POM模型配置
1. <groupID>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**com.zjyy** 公司项目唯一标识,同时也是项目jar打包路径
2. <artifactID>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**zjyy-parent** 项目唯一标识
3. <version>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**1.0.0-SNAPSHOT** 项目版本,尚处于不稳定版,非RELEASED
4. 查看自定义POM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~: mvn help:effective-pom
5. 查看Maven链接服务器配置cat ~/.m2/settings.xml mvn help:effective-settings
6. 


### 开发环境:
Spring4.0 注解配置依赖(启用)
### IOC+AOP
控反+面向切面. 工厂+反射
### spring-boot
用main()启动服务,无须war包.
一个boot一般默认一个服务项.目录结构如下![image](http://note.youdao.com/yws/res/7688/3899228B28EF44F6BA2FAD8B3B1E638C)

### boot插件:
### Sonar-project.properties
项目代码质量测试

### RESTful接口
1. 满足REST(represetational status transfer)状态描述传输服务的架构设计就是RESTful风格的.
2. 
### MAVEN项目管理
Maven "专家"、"内行"，基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。

Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理并自动更新,少许或无须配置也可访问新功能。

Maven通过构建的依赖一定要是RELEASE版本的(本地respostiry绑定版本号),而Snapshot版本的指不定哪天就更新了,Maven会自动更新到本地repository造成未知BUG.



## 工具栈
1. mvn 私服 配置~/.m2/settings.xml 
    
        研发团队内部统一使用Maven管理版本依赖及项目构建，Maven代理私服使用Sonatype Nexus.http://nexus.dev.dtstack.cn/nexus
2. edas 改善 分布式 ~/edas-center-config/startup.sh
3. postman 测试接口 post http://127.0.0.1:9003/login/accountLogin 
4. body ![](https://ws4.sinaimg.cn/large/006tNbRwly1fwa0p4vylej315o0aejrq.jpg)
4. swagger 接口注释文档
## edas配置下的服务端口
![image](http://note.youdao.com/yws/res/7442/2A0E281A751646AC8AC99D8C816930F2)

## 依赖栈
1. MySQL依赖
```
graph TB
zjyy-uc-->mysql
zjyy-bcs-->mysql
zjyy-batch-->mysql
```

1. op服务
![](https://ws2.sinaimg.cn/large/006tNbRwly1fw9x8xjntaj30z80gcaaz.jpg)
2. publish服务
![image](http://note.youdao.com/yws/res/7430/F0BAB981726143FD90355D1036DFFD4E)
## 查看项目代码
1. 从配置文件入手，弄清楚页面到Action/Servlet的配置关系。

2. 搞清楚代码提交的方式，前台请求如何传递到后台，又是如何返回到前台页面的，这里以Login页面为最佳切入点。

3. 从处理Login的Action/Servlet中观察，看在session中记录了多少重要的数据，后面程序又是怎样用到这些数据的。
## 标签设计构思  
> 弄清楚标签的post逻辑

1. 利用**抽象工厂设计模式+反射**达到输入一级标签,读取,枚举确认后.自动排出二级标签的目的
2. 一级标签怎么搞:点击确认后,对比枚举值,用where语句跳转


## 干活方法
1. 利用postman不断访问各种标签相关接口
2. 传入body参数,看返回

## 利用Postman测试op模块的"login/accountLogin"接口
### 配好本地EDAS中心
![](https://ws3.sinaimg.cn/large/006tNbRwly1fwa2platjdj30po044wf8.jpg)

### 配好模块APP启动入口程序的JVM
    -Dvipserver.server.port=8080 -Dpandora.location=/Users/huangmengyao/.m2/repository/com/taobao/pandora/taobao-hsf.sar/dev-SNAPSHOT/taobao-hsf.sar-dev-SNAPSHOT.jar
![](https://ws4.sinaimg.cn/large/006tNbRwly1fwa2sr142tj31kw0qotaa.jpg)

### 启动模块
> 根据jvm调优,模块启动后会注册到本地EDAS中心
1. 根据依赖关系**顺序启动**:bcs,uc,op三个模块
![image](http://note.youdao.com/yws/res/7474/BA3B34502FC849CCB3422261674A6CE8)
2. 可以看到启动后的结果
![image](http://note.youdao.com/yws/res/7478/C3ED0A880F124C1982D053621CCCF50A)
3. Op模块占用9002/端口,故本地post地址是http://127.0.0.1:9002/login/accountLogin

### 本地EDAS查看服务是否注册
1. 登入127.0.0.1:8080/ 查看![image](http://note.youdao.com/yws/res/7489/9084E19956AF404F910E18F3578A7BC9)
2. 刷新已注册服务
按cmd+r刷新![image](http://note.youdao.com/yws/res/7492/AB4134FF41B1481CB4E5D1A68A690326)

3. 确认服务都已成功注册

## IDEA搜索接口名与所在的服务
> 根据大致的接口吗确定下具体的接口名
1. 进入IDEA:cmd+r+shift.搜索/login/接口
2. 注意要找op服务的
3. 以.java结尾的,说明是代码文件
4. 以@PostMapping注释的,说明是接口
![image](http://note.youdao.com/yws/res/7501/942EA5874ADA4554AB600892430DAB4F)

5. 双击选中行,进入具体代码.确认接口名"/login/accountLogin"
![image](http://note.youdao.com/yws/res/7505/F410E533673C4795A2F17ACD41A1C10E)

## Postman测试接口
1. 输入post接口地址
![image](http://note.youdao.com/yws/res/7511/77BCCB9E741E43F6A74E2191C823B30F)
2. body-->raw-->json-->输入请求内容
![image](http://note.youdao.com/yws/res/7516/76DC96F7639F42E6BB6BE5C28CF67AE8)
3. 可查看header属性是否变为json
4. 不知道requesr-Payload怎么办?
## 登入成熟的中金易云一期项目后台管理账号
1. http://47.100.111.124:8001/manageOperat/manageTags
2. 18812341234 abc123 888
3. 登入的同时cmd+alt+i打开浏览器开发者模式追踪request请求报文
4. Network-->XHR-->accountLogin-->底部RequestPayload ![image](http://note.youdao.com/yws/res/7526/D2A1C6DAD6FB45A3A258C9C9B299BD54)
5. view source并复制报文![image](http://note.youdao.com/yws/res/7531/940A7ADC07524AEF8FBDF10BB74ADBB9)
6. 返回postman,粘贴![image](http://note.youdao.com/yws/res/7534/ED9CA6F4640D4DDA918AC1E9B95C0405)
7. 注意JS格式是否正确
8. send 接口测试成功! ![image](http://note.youdao.com/yws/res/7537/8B98840472AD45B4BB63E1D5A9642921)

## 查找标签模块用到的数据表
### 配置MYSQL
1. class : com.mysql.jdbc.Driver
    
        jdbc:mysql://{host::localhost}?[:{port::3306}][/{database}?][\?<&,user={user},password={password},{:identifier}={:identifier}>]
2. IDEA配置MySQL![image](http://note.youdao.com/yws/res/7552/744E52CEF4CC485095D6A6F1873AFB9D)

3. 寻找配置数据表的xml文件

根据一期web页面的Network选项,定位接口注释名

![image](http://note.youdao.com/yws/res/7565/E7AE4B1341FD484CB3639C6ADE432054)

![image](http://note.youdao.com/yws/res/7557/2F78A9DAD99C4F78A5DBA109D55CD8BD)

2. 根据接口注释名在代码里做全局查询
找到@RequestMapping映射请求
![image](http://note.youdao.com/yws/res/7574/F30B4734C4A844FC9D409087640DABC9)

3. 进入文件后先定位一下文件位置
![image](http://note.youdao.com/yws/res/7579/18B25217912E47B8B665610CEEEED801)
4. 鼠标移动到在类名,按住cmd+b跳至下一条子类
5. 直至子类跳自身![image](http://note.youdao.com/yws/res/7583/7016865F6E204DC183A19BEC3AB46D6B)
6. 进入xml文件后
把6张表的设计都过一遍
![image](http://note.youdao.com/yws/res/7587/EA8202ADCB554CCAAD6F644A94D24F2B)
7. 了解MyBaits的xml配置

**如果你搜索只是返回一个值，比如说String ，或者是int，那你直接用resultType(类似于方法返回类型数据)就行了。
但是你如果是返回一个复杂的对象，就必须定义好这个对象的resultMap((类似于构造方法返回对象)的result map。**

```
举个例子吧，例子以ibatis为例：
你有个User对象，拥有两个字段id,name。 
1.你要获取id为123的name
String name = (String) queryForObject("getUserNameByID", id);

<select id="getUserNameByID" resultType="java.lang.String">
定义参数getUserNameByID,id. 返回String型. 业务逻辑为SQL语句
 Select name from User where id =#{id}#
 </select>
 ```
 ```
 2.你要获取整个User对象
User user = (User) queryForObject("getUserByID", id);

<resultMap class="包.User" id="User">
  <result property="id" column="ID" />
  <result property="name" column="NAME" />
 </resultMap>

<select id="getUserByID" resultMap="User">
 Select ID,NAME from User where id =#id#
 </select>
```
### 理清数据表关系
bcs模块下
1. 首先,我们在IDEA上运行我们的项目,通过JVM参数连接到本地EDAS中心.
2. 我们事先应在edas中心里配置好zjyy的数据库地址
![image](http://note.youdao.com/yws/res/7782/D20BEA1697624126815FA346D057F887)
3. 用navicat连上去看一看.项目测试主机地址:![image](http://note.youdao.com/yws/res/7789/C1DB5ED1EFFB44488E371383018C1038)
4. 发现里面有诸多表,其中dim_tag@zjyy_publi_data ![image](http://note.youdao.com/yws/res/7793/3816A8783EA4458E869E5318D4457B65)
5. 就是项目代码zjyy-bcs-app的resource里的dim_tag-mapper.xml MyBaits映射表![image](http://note.youdao.com/yws/res/7806/F94BC2ACCE424EF79FE5F5D311DF7DC9)
6. 自此项目代码本地编写或测试时对数据库的增删改查链路摸清.


### 测试updateStatus接口


定位接口:![image](http://note.youdao.com/yws/res/7617/7CF271250DA5433B8EBFB70D758DFFAA)

找到tag/updateStatus接口![image](http://note.youdao.com/yws/res/7621/D76E728E5972499CA9A067FC57A740CA)
根据tagMapper解析的namespace类里的属性,确定BODY里要传入的JSON内容.
![image](http://note.youdao.com/yws/res/7611/2058119BC7524C949878D5F095911C67)

### 编写测试接口
#### 接口一
1. 原型要求![image](http://note.youdao.com/yws/res/7813/8F6E2BF8DEFA4FCDA670E783B2F29CE4)
2. 很明显接口一应该把把所有一级类目的tag_cate1_id,tag_cat1_name与两个字段的内容发送给前端.
```json
    
"result_code": "200",
"result_message": "查询成功",
"data":{
    "tag_cate1_id":1,
    "cate2_len":10,
    "sites":[
        {
        "cate2_id":1,
        "cate2_name":"null"
        },
        {
        "cate2_id":2,
        "cate2_name":"null"
        },
        {
        "cate2_id":3,
        "cate2_name":"null"
        },
        {
        "cate2_id":4,
        "cate2_name":"null"
        },
        {
        "cate2_id":5,
        "cate2_name":"null"
        },
        {
        "cate2_id":6,
        "cate2_name":"null"
        },
        {
        "cate2_id":7,
        "cate2_name":"null"
        },
        {
        "cate2_id":8,
        "cate2_name":"null"
        },
        {
        "cate2_id":9,
        "cate2_name":"null"
        },
        {
        "cate2_id":10,
        "cate2_name":"null"
        }
        ]
}


```json
{   
    "status":"success",
    "tagId":"1",
    "data":[
        "modify_history":"乡村,青春,文学,人物,故事",
    ]
    
}
```

# 任务
本周完成编写6个接口的任务,
下周完成每个接口的自测,修改,DeBug
## 接口介绍
1. 标签查询筛选结果
2. 标签修改
3. 打开修改标签
4. 根据一级类目找二级类目
5. 原地修改
6. 两级类目查询筛选结果

## 先修知识
1. @RestController
    1. @Controller处理Http请求用.即这个类下面一定会有@RequestMapping(value="\hello",method = RequestMethod.POST)
2. @RequestMapping
    
3. @ResponseBody 
### SOA
> Service Oriented Architecture

SOA精确定义接口进行通讯.缺点是多服务数据通讯协议之间转换过程复杂.ESB性能瓶颈.
### MicroServices
1. 服务按业务划分
2. 服务间通过轻量级API调用
3. 支持不同语言
4. 独立部署,独立优化与扩大
**缺点**
1. 网络开销大,运维成本高
## SpringBoot
1. 习惯大于配置,尽量使用自动配置.同时使用注解代替XML配置.
@Controller MVC里的控制器
@RequestMapping 映射(接收)Web请求.通常用在类或方法上
@RequestParam 将Web请求的数据投到功能方法的参数上
@ResponseBody 方法返回的内容先放到Response里,而不是作为资源直接传回去.
@RequestBody 用于读取Http请求的字符串内容 通过Http提供的HttpMessageConverter接口将读到的内容转为XML,或JSON并传到Controller方法的参数.

@PathVariable 用于接收请求路径参数,并放到方法参数上.
@RestController 组合注解,等价于@Controller,@ResponseBody 将控制器返回的资源放进Response




```
graph LR
subgraph 
    感知层技术-->传输层技术
    传输层技术-->控制层技术
end
```
## MyBatis映射必知
- 使用resultType的时候，

## MyBatis工作顺序
1. paramType
2. SQL
3. resultType直接映射 或 resultMap利用自定义map生成Map
4. resultType="java.util.Map" 可将查询结果是单行记录（单个对象）的表转化为反射Map<Field,Value>
## MyBatis利用List获取自增ID时必须声明paramType
![image.png](http://note.youdao.com/yws/res/11375/WEBRESOURCE1f4bc38775f1998c7473a493cd2b4f9f)


## 利用子查询轻松实现批量插入
```
INSERT INTO auth_role_data_permission_rel ( store_id ) SELECT
store_id 
FROM
	dim_store_relation 
	LIMIT 5
```
## 缓冲表，流水表
- 流水表，比如将传入数据插入到Order表，将自增生成的id作为orderId和传入数据同步插入到Order_history这张表
- 仅仅少许前后时间差
## SQL去重
- limit 1
- distinct
- order by
- 数据量少时用Set<T> 接收数据

## 读取Excel的流程
    获取Excel表里第一行的用户名数据
![image.png](http://note.youdao.com/yws/res/11353/WEBRESOURCEa8bcf2e65969eff17f550c2ad8a93421)
```
- MultipartFile file
- String fileName = file.getOriginalFileName()
- InputStream io = file.getInputStream()
- Workbook wb = fileName.equals("xls")?new HSSFWorkbook(io):XSSFWorkbook(io);
- Sheet sheet = wb.getSheetAt(0);
- Row row = sheet.getRow(num);
- Cell cell = row.getCell(0);
- String userName = cell.getStringValue();
```

## 事务的用法

![image.png](http://note.youdao.com/yws/res/11356/WEBRESOURCE6de81468d84ce700c32cd690dd981b4a)
```
当且仅当 捕获到异常时，事务回退，即数据库不执行方法栈里的DAO操作
```
配合 main方法![image.png](http://note.youdao.com/yws/res/11361/WEBRESOURCEefb4027d858d4f62e261517dd12802fd)
## Mybatis最标准最万能写法
- DAO @Param()支持同时传入多个对象与基本对象！从此摆脱Query类里集成太多非前端传来参数的尴尬
![image.png](http://note.youdao.com/yws/res/11324/WEBRESOURCE9e62e58ead7419b56c1b2e57b31b682a)
- XML resultType自动映射到DO上！
![image.png](http://note.youdao.com/yws/res/11326/WEBRESOURCEe1cb7e672bce3a77f28b23b68da9df12)
- DO实体类 需要打@Alias(),自动带入全限定名！不支持interface
![image.png](http://note.youdao.com/yws/res/11331/WEBRESOURCEe4357ac941f23c27269419ffce6d0e93)

## MyBatis返回Map

![image.png](http://note.youdao.com/yws/res/11322/WEBRESOURCE477417e8f4478e373bd592cbda0c8694)


## Array与List的区别
- Array不可扩容，size不可修改（占用连续存储空间的数组）
- List的size是dynamically的，可以动态增长（链表）
- 

## 反射怎么用
    xxVO.class等价于    
    xxvo.getClass()
1. 获取某个方法的参数名
    
```
public static List<String> getParameterNameJava8(Class clazz, String methodName){
        List<String> paramterList = new ArrayList<>();
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            if (methodName.equals(method.getName())) {
                Parameter[] params = method.getParameters();
                for(Parameter parameter : params){
                    paramterList.add(parameter.getName());
                }

            }
        }

        return paramterList;
    }
```
2. 获取对象的属性对象数组
```
public void printFieldNames(Object obj, Foo... foos) {
    List<Foo> fooList = Arrays.asList(foos);
    for(Field field : obj.getClass().getFields()) {
         if(fooList.contains(field.get()) {
              System.out.println(field.getName());
         }
    }
}
```
3. 通过reflectRun()与reflectSet()方法根据方法名反射调用节点类内的方法
```
//要赋值的变量所在的类
	private Object obj;
	public Reflect(Object obj){
		this.obj=obj;
	}
//method为方法名，value为传入参数（根据自己实际情况做修改）
	public void set(String methodname,String value){
		try {
		//获取方法
			Method m=obj.getClass().getDeclaredMethod(methodname, String.class);
			//调用方法（value根据自己实际情况做修改）
			m.invoke(obj, value);
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public String get(String methodname){
		String value=null;
		try {
			Method m=obj.getClass().getMethod(methodname);
			value=(String) m.invoke(obj);
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return value;
		
	}
}
```

## 水平与垂直
- 什么是水平：水平就是 与他人对比
- 什么是垂直：垂直就是 与更深奥的自己对比

## Collection<>接口方法踩坑
- 


## 集合类root接口
    Collection<E>
    Map<K,V>

## 基本数据类型的大坑
    1. 基本数据类型不能被序列化
    2. 基本数据类型不能被塞进集合结构里
    
## 三级树与父子类
- 有Tree结构就一定有父子节点
- 子节点除了描述自身状态的字段外，还必须额外多一个看似与它本身无关联，但却是将子节点关联父节点的重要的桥梁--子节点里的父ID


## 将拥有一对多字段的List转化为Map
- DistrDeptNumDO里有四个字段：productId,deptNum[等价于count(groupId)],groupId,productStatus
- 其中productId字段一对多groupId与productStatus这两字段。
- 于是我们就可以将List<DistrDeptNumDO> 巧妙地抽取prouctId，转化为Map<Integer,DistrDeptNumDO> 完美利用stream流Collectors.toMap方法
```
/** 各个ProductID对应的DeptNum,GroupID和group对应的ProductStatus */
String productIds = StringUtils.join(products,",");
List<DistrDeptNumDO> deptNums = distrProductMapper.countDept(productIds);
Map<Integer,DistrDeptNumDO> deptNumsMap = deptNums.stream().collect(Collectors.toMap(d->d.getProductId(), d->new DistrDeptNumDO(d.getDeptNum(),d.getGroupId(),d.getProductStatus())));
```
## 参数校验
    Assert.notNull(query.getDeptName(),"缺乏机构名字信息");

## cmd + e
    获取IDEA最近打开类文件列表
## 项目大局技巧
- 做两个比较相像的模块
- 先保证有两套Controller与接口。
- 再保证一套可复用的Client,Service,RestController,Manager,Mapper,DO,VO,Query。
- 即可成功将两套大项目合成一套写。
- 两套的为差异处理可以放在在Controller做。


## MySQL表的内循环
    一张订单表表通过充分利用id与status两个字段，可以在不额外建一张表的情况下。通过rel_roder_id这个字段，对于status为人工停止服务，到期停止服务，续费这三种情况时。通过将对应的id赋值到rel_order_id，使得新建的订单状态能关联上表内的开通记录。
    即只有status为开通的记录id才能被用于赋值。



## 关系型VO
- 一个关系型VO实体应当由多张MySQL关系表组成
- 比如机构后台权限产品VO实体，由产品字典表，权限字典表，产品权限关联表，产品机构关联表，机构字典表等五张表组成。


## 12.26踩坑实录
1. Controller层接收参数必须是引用类型，不允许用基本数据类型接收
2. Controller层有时会与基础服务层的Service层重名,稍微改动下类名就好
3. postman的from-data格式传参数是个神器，可以同时传文件与参数！

## git拉出分支操作
1. 从master拉取分支git checkout -b dev-TC
2. 立即推送git push origin dev-TC:(origin)dev-TC
3. 立即删除本地的dev-TC
4. 从远程dev-TC重新拉取dev-TC到本地，从而间接切换远程分支

## 独立开发一款产品时
1. 先根据PRD梳理业务使用的流程图，打通各个功能的使用顺序
2. 再根据流程图设计表结构与表字段，画出从头使用产品的ER图，与使用一段时间后，用户从登陆开始，需要查的所有id所在表
3.  


## Mybatis在@Select()里自动select in
```
@Select("SELECT * FROM admin_role WHERE id IN (#{roleIdList})")
@Lang(SimpleSelectInLangDriver.class)
List<RoleDO> selectRolesByRoleId(List<Integer> roleIdList);




package com.szss.admin.common;
 
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
import org.apache.ibatis.mapping.SqlSource;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.scripting.xmltags.XMLLanguageDriver;
import org.apache.ibatis.session.Configuration;
 
/**
 * @author Allen
 * @date 2018/3/9
 *
 * 自定义Select in 注解,用于动态生成Select in 语句
 */
public class SimpleSelectInLangDriver extends XMLLanguageDriver implements LanguageDriver {
 
    /**
     * Pattern静态申明
     */
    private final Pattern inPattern = Pattern.compile("\\(#\\{(\\w+)\\}\\)");
 
    /**
     * 实现自定义Select in 注解
     * @param configuration 配置参数
     * @param script 入参
     * @param parameterType 参数类型
     * @return 转换后的SqlSource
     */
    @Override
    public SqlSource createSqlSource(Configuration configuration, String script, Class<?> parameterType) {
 
        Matcher matcher = inPattern.matcher(script);
        if (matcher.find()) {
            script = matcher.replaceAll("<foreach collection=\"$1\" item=\"_item\" open=\"(\" "
                + "separator=\",\" close=\")\" >#{_item}</foreach>");
        }
 
        script = "<script>" + script + "</script>";
 
        return super.createSqlSource(configuration, script, parameterType);
    }
}


等价于

@Select("SELECT * " +
        "FROM admin_role " +
        "WHERE id IN " +
        "<foreach item='item' index='index' collection='list'open='(' separator=',' close=')'>" +
        "#{item}" +
        "</foreach>")
List<RoleDO> selectRolesByRoleId(List<Integer> roleIdList);

```


## Mybatis临时转义
```
where id = #{id,jdbcType=INTEGER}
```
在@Select()中使用if
```
@Select({"<script>",
    "SELECT * FROM tbl_order",
    "WHERE 1=1",
    "<when test='title!=null'>",
    "AND mydate = #{mydate}",
    "</when>",
    "</script>"})
```

## 工具类三
- StringUtils.isNotBlank()
- CollectionUtils.isNotEmpty()
- StringUtils.equals( , )

## 接口设计二
    很多字段都有共同的功能，Query类就不应该以字段为主，应该以功能为主
```
//比如在网页上对图书品种数与图书热度两个字段进行排序，就不应该直接传"bkCnt":"desc","bkHot":"desc".
//因为人类点击网页时一次只能点击一个地方，即不会出现同时点击两个地方的情况。故接口可以改造成
"sortName":"bkCnt",
"sortType":"desc"
//把通用的功能提取出来，并加以描述，这就是抽象思维

```

## 按某字段给列表排序
```
List<BookListVO> bookListVOS =  
bookListManager.list(bookListQuery).getRecords();
        
Collections.sort(bookListVOS, 
Comparator.comparing(BookListVO::getVarietyNum));
    }
```

## 将一套系统耦合拓展成两套
`即两套代码都在一套springBoot，且尽量写成一套controller`
当VO不能复用时
- controller层必须两套，目的是区分出url路径
- service层必须两套，调相同的service或manager层
- 
当VO能复用时
- controller层可以一套，url路径common开头
- service层可以一套

## JSONs类三大法宝
```
1.String str =  JSONs.toJSON(xxVO);
2.String str =  JSONs.toJSON(xxVOs);
3.String str =  JSONs.toJSON(xxVOs);

```

## 拼接SQL的好处
- 不受XML格式的影响，少一个500报错的地方
- SQL哪怕拼接错了，只会SQLException，返回[]给前端。极大的保证了服务的稳定性
- 但是记住@Select里 '=' 用#{}拼接， 'in'要用${}拼接
- 代码里拼接统一按$的要求来
## 给List<DO> DOs排序
```
//拿到compareStoreSortDOS后，里面已经根据order by 排序好
//将排序好的store_id -->利用增强for循环+map手动匹配排序号
Map<String,String> map = new HashMap<>(100);
for(int i = 0,len = compareStoreSortDOS.size();i<len;i++){
    map.put(compareStoreSortDOS.get(i).getStoreId,(i+1)+"");
}
//DOs再根据map里的storeId-rankId键值对为自身的rankId赋值
compareStoreSortDOS.forEach(c->c.setRankId(map.get(c.getStoreId)));
```
## SQL利用自定义表变量 生成查询记录的排名
```
SELECT @rank := @rank + 1 
AS rank_id,store_id,sl_prod_cnt,sl_prod_rate,sl_index 
FROM store_cate_channel_mix_1m s,( SELECT @rank := 0 ) p 
WHERE store_id 
IN ('1101000111101011101011','11010001111010111010
13','1101000111101011101014') 
ORDER BY sl_index DESC 
LIMIT 10;
```


## Update时必须有where条件
```
update store_cate_lv3_1m 
set biz_month= '201801' 
where biz_month = '201812'
```

## 将手写的JSON数据转为对象
    通过将手写的JSON数据转为具体对象，返回固定数据供前端调试
```
//借助TextLab软件写好data部分的JSON后 转为 Shrink形式 作为final String粘贴进代码内。

public final String JSON = "[ { \"title\": \"销售码洋\", \"type\": \"slOrdAmt\", \"data\": \"0\", \"avg\": \"0\" }, { \"title\": \"销售册数\", \"type\": \"slBksCnt\", \"data\": \"0\", \"avg\": \"0\" }, { \"title\": \"客单价\", \"type\": \"amtPerCust\", \"data\": \"0\", \"avg\": \"0\" }, { \"title\": \"客单量\", \"type\": \"cntPerCust\", \"data\": \"0\", \"avg\": \"0\" }, { \"title\": \"动销品种数\", \"type\": \"slProdCnt\", \"data\": \"0\", \"avg\": \"0\" }, { \"title\": \"动销率\", \"type\": \"slProdRate\", \"data\": \"0\", \"avg\": \"0\" }, { \"title\": \"门店坪效\", \"type\": \"storeAreaEffectiveness\", \"data\": \"0\", \"avg\": \"0\" }, { \"title\": \"客流量\", \"type\": \"enterCustCntUnit\", \"data\": \"0\", \"avg\": \"0\" }, { \"title\": \"客流转化率\", \"type\": \"enterCustCntUnitRate\", \"data\": \"0\", \"avg\": \"0\" } ]";

//TODO 向R<List<CompareCoreIndexVO>>.data赋入假数据 
compareCoreIndexVOS = JSONs.fromJSONList(JSON,CompareCoreIndexVO.class);
return compareCoreIndexVOS;
```

## 接口设计--活用Manager与BaseService--分治与归并
利用拼接SQL在Manager层与DAO层`分治`查不同查询维度下的数据库
利用List<VO>VOList `归并`多个List<DO>DOS 生成List<VO>VOS
```
<!---->参考对比店分析，Top50书籍的接口设计
1. 先用storeId与时间维度拿到本门店销售册数top50的prodId
2. 处理时间维度，timeType为nd的，将searchTime通过枚举类转为字段后缀,返回给query里的searchTime
3. 将查出来的prodIdList根据Strings.format("'{}'",StringUtil.join(prodIdList,"','");转为可以拼接到@Select("")的SQL里的${searchTime}
4. 如果是在代码里拼接SQL，则必须严格按照$的要求拼接，即{}里是String的要改造成'{}'

- 不要把所有业务逻辑放Service层
- 一些Service层通用的业务代码放BaseService
- service层可以根据查询维度（isMoreDay) 做简单的SQL关键语句拼接
- 一个Manager层的方法里根据查询维度（时间等）调用不同的Mapper方法。
- 一个Mapper对应一个系列表
- 一个Manager对应一种DO
```
## 利用假数据保证服务稳定性

1. 利用三元操作符对传来的参数造假
2. ![image.png](http://note.youdao.com/yws/res/10972/WEBRESOURCE3c309661c181d217f38d713575dd732f)
3. 利用Optional.ofNull().orElse(" , ")
4. 对从数据库里捞出的数据做一个判空与造假。

## MySQL拼接字符串
concat_ws(":",)
![image.png](http://note.youdao.com/yws/res/10967/WEBRESOURCE3f83fd2fe9b3248ec2b25c7b1cada272)


## HashMap的妙用
```
任意两个字段存入map后
都可以转一手
用任意两个来自其他DO的属性去接收
从而实现自动转换属性名，值不变

saleBehaviorDicDOS.forEach(s-> saleBehaviorMap.put(s.getSaleBehaviorId(),s.getSaleBehaviorName()));
dimSaleBehaviorDOS.forEach(d->d.setSaleBehaviorName(saleBehaviorMap.getOrDefault(d.getSaleBehavior(),"")));
```

## MySQL操作
```
case when ... then 等价于if() do{}

SELECT CASE 11 WHEN 1 THEN 'one'
WHEN 2 THEN 'two' ELSE 'more' END; //case11表示可跟11个条件，case表示只可跟一个条件

SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END;

```

## 用自定义的MySQL表代替枚举操作，可无限拓展，可多人拓展，且互不冲突
- 我们一但知道枚举元素里某个属性的值，就一定能知道这个枚举元素其它属性的值
- 数据库里的表也有相同的特点
- 一旦知道表里某一行某个唯一字段的值，就一定能知道该行记录其它字段的值
- 并且表可以拓展大量的字段，还不用像枚举类那样必须声明实例变量，构造方法以及遍历方法，非常方便。
- 同时表还可以通过加个user_name这个字段让多个开发者自己拓展自己的枚举字段，互不冲突


## MySQL 0的妙用
- 笛卡尔积查询维度的字段间会相互干扰，可以将某个维度不为‘0’的行里该维度以外的字段置'0',从而避免笛卡尔积干扰
- 表里字段为varchar时，若cate_lv1_id = 0 则表示忽略这条条件查询语句

## 编程感悟·作用域
- System.out.println("123 "+123)；与System.out.println("123+"+123);的区别
- 双引号之内，是String天下，一切按String的规则；
- 双引号之外，是Java语法的天下，一切按Java的语法办事；
- 命名一个变量 使程序从单调的语法，富有生动的描述含义。
![image.png](http://note.youdao.com/yws/res/10917/WEBRESOURCE0764804cc69e2abaa97f50a0b6ef0e86)
- Boolean isYear = "y".equals(timeType)
- if(isYear) 表示如果前端传来的时间类型是年
- 与if("y".equals(timeType)) 表示如果前端传来的时间类型是年
- 二者相比前者更贴近自然语言，这顿悟妙不可言

## 响应给前端HashMap的好处
- 普通的VO对象里的属性名是定死的，只能传不同的属性值进去。
- HashMap里key-value对是灵活的，想怎么传就怎么传。即属性名是可以无限设置的。而且根据属性名获取。

## MySQL同时查询多条SQL 并将结果合成到一张表里
```
select id from store_cate_channel_mix_1d where channel_lv1_id = '渠道1' union ALL
select id from store_cate_channel_mix_1d where channel_lv1_id = '渠道2' union ALL
select id from store_cate_channel_mix_1d where channel_lv1_id = '渠道3'
```

## 处理时间类
```
String localDateTime = LocalDateTime.now().plusMonths(-1).format(DateTimeFormatter.ofPattern("yyyyMM"));
System.out.println(localDateTime); //打印上一月 201811

/** */
DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

<!--将当前信息转换为格式的String -->
LocalDateTime time = LocalDateTime.now();
String localTime = df.format(time);
<!--按格式输入特点的时间-->
LocalDateTime ldt = LocalDateTime.parse("2017-09-28 17:07:05",df);
```

## 接口设计
1. 接收哪些参数 query
2. 用哪些枚举类拓展这些参数 enum
3. 查怎么查，查哪些 sql
4. 查完后怎么转化 do->vo
5. 怎么给出去 vo->list 或 map


## 尽量不要抛异常
- 真有问题就返回一个空VO对象给客户，反正页面绝对不能报错。
- 调试时，可以抛个异常看看错误在哪里，但是提测时一定要改回来。把抛异常的地方全部改成返回空对象！


## 字符串拼接用法
```
Strings.format("{}_{}","store","d")；
//拼接出“store_d"去有DAY("store_d","store_cate_channel_mix_1d")的枚举类里取·表名·
```
```
String selectStr = "sl_ord_amt,sl_bks_cnt,amt_per_cust,cnt_per_cust,sl_prod_cnt,sl_prod_rate,enter_cust_cnt_unit,enter_cust_cnt_unit_rate,store_area_effectiveness";
List<String> selectList = Arrays.asList(selectStr.split(",")); //制作原始字段名列表


```


## List<String> 转String
```
List<String> list1 = {"abc","defg","hijk"};
String ss = String.join(",", list1);
```

## MyBatis批量插入
```
<!-- 批量插入 -->
    <insert id = "insertGroup" parameterType="java.util.List" useGeneratedKeys="false">
      insert into
      <include refid="table_name"/>
      (store_id,compared_store_id,compared_store_name,compared_store_scale_id,compared_cent_id,compared_cent_name,compared_store_city)
      values
        <foreach collection="compareSetPOS" item="item" index="index" separator=",">
            (
            #{item.hostStoreId},
            #{item.storeId},
            #{item.storeName},
            #{item.storeTypeId},
            #{item.centId},
            #{item.centName},
            #{item.cityName}
            )
        </foreach>
    </insert>
</mapper>
```
## Swagger  目录与前缀
```
@Api(tags =API.COMMON_STORE) //目录-通用组 "门店通用属性"
@RestController
@RequestMapping(API.API_COMMON) //路径前缀 api/common
```
API
```
    String API_DISTR            = "api/distr";
    String API_STORE            = "api/store";
    String API_COMMON           = "api/common";

    String COMMON_TANBLE        = "通用-表格";
    String COMMON_STORE         = "通用-门店属性";

    String HOME                 = "首页";
    String SALES_ANALYSIS       = "销售分析";
    String SALES_TREND          = "销售分析-销售趋势";
    String BOOK_RANK            = "销售分析-图书排行";
    String CROSS_ANALYSIS       = "销售分析-交叉分析";
    String STORE_ANALYSIS       = "销售分析-门店分析";
    String PUBLI_COMP_ANALYSIS  = "销售分析-出版公司分析";
    String COMP_ANALYSIS        = "销售分析-发行公司分析";

```
## 千分位处理方法
```
 /** 销售码洋 */
    @Unit(divisor = 100, isGroup = "salePrice")
    private Long   salePrice;

    /** 同类平均销售码洋 */
    @Unit(divisor = 100, isGroup = "salePrice")
    private Long   cateSalePriceAvg;

```

## 学习方法
- 边学边记边联想
- 费曼学习法,一切皆描述
- 心心相印法,看到某处,心里想到的,与实际答案对照.对照中
## 万能项目方法
```
graph LR
原型图-->抽象数据
抽象数据-->表结构
表结构-->dic与mapping
表结构-->业务类型抽象
业务类型抽象-->时间
业务类型抽象-->门店发行集团等组织
抽象数据-->面向过程
面向过程-->面向对象
面向对象-->封装与继承
面向对象-->泛型与工具类
```

## 二期对比度设置页面踩坑心得
- DAO层数据库字段只会按驼峰形式映射到DO实体,想强制转换成想要的字段名,可用`select store_type_id as store_scale_id from table`
- 使用任何工具类,第三方方法,一定要看一遍它的实现源码,发现可能return VO 或return null的地方要改成return VO或return new VO();
- 任何有返回的地方一定要作判空处理(若空,则抛业务异常)
- 无法打断点时,可利用`sut`即`System.out.println(JSONs.toJSON(obj))`控制台查看obj对象的内容
- 接口报错 `400`表示服务运行不到,可能是微服务没重启成功,需重启.`500`是接口内部有NPE,控制台会提示哪个类,第几行出错.可用打断点调试,或toJSON方法解决问题.
- for循环自带index，不必凡事用foreach()。当前元素需要与前后元素联动的话，for是最好的选择。注意for(int i,)

## 同比,环比
- 同比:以去年同期数据为100%来比
- 环比:以上月数据为100%来比

## 正则匹配
```
public static void main(String[] args) {
        String line = "This order was placed for QT3000! OK?";
        String pattern = "(\\D*)(\\d+)(.*)";

        Matcher m = Pattern.compile(pattern).matcher(line);
        if(m.find()){
            for(int i =0;i<=3;i++)
                System.out.println(m.group(i));
        }
    }
```

## 两个对象间如何交互
- 在c对象里运行a与b
- a对象里有个List,同时还有个add方法,list.add()成功则返回true
- b对象是个List
- 当a.add(b.getList().next())成功时,返回true
- 当c对象里,a.add()返回true时,b.remove(current)
- 即通过a事先定好的方法,c获取a的转态后删除b里的某个值,实现a与b的交互


## 接口的设计
```
graph TB
    subgraph 接口设计思想
        前端--关键信息-->后端
        后端--表单式设计要返回的数据-->捞数据
        捞数据--VO实体对象-->JSON树结构(Map<String,VO.List<VO>)
    end
```
1. 先按表单设计要返回的页面摸个模块需要的数据
2. 再将VO实体对象的树结构转化成JSON
3. 交互JSON

## 常见命名思想
- 都是String时 (name,value) 对应 (typeName,typeId)

## 项目分层思路
- 代码不出app层的，所有层都在app里，包括POJO
- 代码跨层的，需要交互的放基础bcs的api层里，如两层都会用到的Query，VO与 RpcService接口层
- 最终在bcs的app的Restful层里实现RpcService。不同的服务间的类文件不能相互调用，智能运行时通过api层交互
- Controller : RestController+RequestMapping , RequestMapping+RequestBody+RequestParam , R<data>+R<pageData> 
- Service : Service
- Manager : Component+ CheckOfR.check() //及时捞出R里的异常信息

## 常见postman异常
- 服务半天运不起来，**极有可能是运行的时候被断点卡住了！！，rebuild时请请关闭所有断点！！**
- 405 请求方式出错
- 500 响应超时
- “请求失败”，大概率Exception异常，最可能是请求参数缺失或错误。
## 序列化
任意类型的数据

## 接收JSON对象,并捞出里面的数据
已知JSON里子对象在代码里对应的实体类
```
Map<String,Bar> map1 = (Map<String,Bar>)JSON.parse(json); 
for (String key : map1.keySet()) { 
System.out.println(key+":"+map1.get(key)); 
} 
/*
```
全新的JSON,没有对应的实体类
```
Map map1 = JSON.parseObject(json);
System.out.println(map1.get("a"));
for (Object mapData : map.entrySet()) {
Map.Entry<String,String> entry = (Map.Entry<String,String>)mapData;
System.out.println(entry.getKey()+"--->"+entry.getValue());
}
```

## JSON的好处
JSON就是一个嵌套的HashMap,反复嵌套Key-Value对,但是
## 常用代码技巧

1. 数组转列表
```
//数组转列表
List<String> list = Arrays.asList(new String[]{"b","a","x"});
```
2. do转vo
```
public class PageUtil{
    public static List<SearchTerm> transformPay(List<DimCentPayMappingDo> t){
        List<SearchTerm> searchTerms = t.stream().map(Vo->{SearchTerm searchTerm = new SearchTerm();
        searchTerm.setFieldValue(Vo.getPayTypeId);
        searchTerm.setFieldName(Vo.getPayTypeName);
        return searchTerm;
        }).collect(Collects.toList());
    }
}
```
3. Date转String
```JAVA
String gmtModified = SimpleDateFormatUtils.dateToStrLong(Date gmtModified)
//等价于
已知Date dateDate
SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-HH HH:mm:ss");
String dateStr = formatter.format(dateDate);
```

4. SQL查询模糊与精准规范--汀池
```sql
精准: cent_id = #{centId}
模糊: cent_name like concat(concat('%',#{centName}),'%')
原因: # 占位符会自动将centName里的'转化为\'
危险操作: cent_name like '%${centName}%'
原因: $符会不加任何过滤地将左右内容与它自身合为一个String,当 cent_name like 's't'时sql报错
```
5. stram流打map包
```
Map<String,DimBookDO> map=bookMapper.queryBooksByIds(bookQuery).stream().collect(
Collectors.toMap(DimBookDO::getBkId, Function.identity()));
```

6. 枚举类理解
```
public enum TimeIdEnum{
    LAST_7("最近7天","1");
    private String name;
    private String value;
    TimeIdEnum(String name,String value){
        this.name = name;
        this.value = value;
    }
    // getter
    // setter
}
```
*test*
```
public class TimeUtils{
    String timeTypeId = TimeIdEnum.LAST_7.getValue();
    //等价于
    new TimeIdEnum("最近7天","1").getValue(); //返回"1"
}
```

## 常量型枚举
- interface内的属性等价于常量
- DISTR_RDS 枚举对象名 "distr_rds" 对应的常量名
```
public enum DSEnum {

    /**
     * distr rds 数据源
     */
    DISTR_RDS("distr_rds"),
    /**
     * publi rds 数据源
     */
    PUBLI_RDS("publi_rds"),
    /**
     * ads 数据源
     */
    ADS("ads");

    private String key;

    DSEnum(String key) {
        this.key = key;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }
}
```

## Map型枚举
- LARGE枚举包对象名 "LARGE" map对应的key,"大型门店"map对应的value；
```
public enum StoreScaleEnum {

    /**
     * 大型门店
     */
    LARGE("LARGE","大型门店"),

    /**
     * 中型门店
     */
    MEDIUM("MEDIUM","中型门店");

    private String name;

    private String value;

    StoreScaleEnum(String name,String value){
        this.name = name;
        this.value = value;
    } //有构造器决定

    public static StoreScaleEnum getAccess(String value){
        for(StoreScaleEnum se:StoreScaleEnum.values()){
            if(se.getValue().equals(value));
            return se;
        }
        return null;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
```
## mybatis xml 查询参数类型转换
```
 where id = #{id,jdbcType=INTEGER}
```
## 建表专用
```SQL
CREATE TABLE `zjyy_store_compare_list` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '自增ID主键',
  `store_id` varchar(64) NOT NULL COMMENT '账号所在门店',
  `compared_store_id` varchar(64) DEFAULT NULL COMMENT '对比门店ID',
	`compared_store_name` varchar(64) DEFAULT NULL COMMENT '对比门店名',
  `compared_store_scale_id` varchar(64) DEFAULT NULL COMMENT '对比门店规模ID',
  `compared_cent_id` varchar(64) DEFAULT NULL COMMENT '对比门店发行集团ID',
	`compared_cent_name` varchar(64) DEFAULT NULL COMMENT '对比门店发行集团名',
  `compared_store_city` varchar(64) DEFAULT NULL COMMENT '对比门店城市',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '逻辑对比，0对比，1取消对比',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `creator` varchar(32) DEFAULT '0' COMMENT '创建人',
  `modifier` varchar(32) DEFAULT '0' COMMENT '修改人',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='对比门店关联表';
```

## MybatisPlus的两种DAO映射方法
DO
```
@Slf4j
@Data
public class BaseDO {


    @TableField(value = "id")
    private Long id;

    @TableField(value = "gmt_create",fill = FieldFill.INSERT)
    private Date gmtCreate;

    @TableField(value = "gmt_modified",fill = FieldFill.UPDATE)
    private Date gmtModified;

    @TableField(value = "creator",fill = FieldFill.INSERT)
    private String creator;

    @TableField(value = "modifier",fill = FieldFill.UPDATE)
    private String modifier;

    @TableField("is_deleted")
    @TableLogic
    private Integer isDeleted;
}
```
```
@Data
@TableName("tbl_book")
public class BookDemoDO extends BaseDO {

    @TableField("bk_id")
    private Long bkId;

    @TableField("bk_name")
    private String bkName;

}
```
DAO
```
@Select("select bk_id,bk_name from tbl_book  where bk_name like '%${bkName}%' ")
    List<BookDemoDO> queryBookPage(BookDemoQuery bookDemoQuery);
```
自动映射

还有一种就是老Mybatis写法



## 查看本地git秘钥
1. ssh-keygen -t rsa -C "471055446@qq.com"
2. cd ~/.ssh
3. cat id_rsa.pub
![image](http://note.youdao.com/yws/res/9433/BC4256DBED6C4DA2BC2FD3F9356BDED8)

## 项目流程
## 开发规范

```
DO-->数据库操作结果实体
VO-->DO转VO给前端
VO-->Filter过滤给前端
```

#### 1. 增删改操作两个以上,用事务@Transactional(rollbackFor = BizException.class)
#### 2. op服务只是拼接服务:controller-->ServiceClient-->跳转到bcs的service对外暴露接口层
#### 3. bcs-api的service层通过加```@FeignClient("zjyy-bussiness-core-service")```注解实现对其服务暴露接口
#### 4. bsc-app的controller层是对api-service层的实现,这一层只做异常报错处理```private static final Logger logger = LoggerFactory.getLogger(DimTagRestController.class);```
#### 5. 比如更改类目名,```try{ if(updateCateName(Model){ return ZjyyResponse<> }
#### 6. POST可以发生body请求,可以发送单个参数请求.GET就只能发送单个或多个并联参数,后台要以多个@RequestParam并联接收参数


### 开发流程
```
graph TB
需求提交-->原型分析
原型分析-->接口设计
接口设计-->接口文档
接口文档-->代码接口
代码接口-->自己测试
自己测试-->前端联调
前端联调-->部署测试
部署测试-->两端联调
两端联调-->正式测试
正式测试-->上线发布
```
## 中金易云标签管理模块复盘
### 一.SELECT标准流程
> 查询并分页

### 二.POST标准接收设计
![image](http://note.youdao.com/yws/res/9427/A2D59B5705C74E38B49E7B042B0C573F)
### 三.GET标准接收设计
![image](http://note.youdao.com/yws/res/9424/EDF0CFE13E9A4F8AAAC35AC418AE062B)
### 四.INSERT标准流程

### 五.UPDATE标准流程

### 六.DEBUG标准流程

### 七.前后端联调,部署,提测

### 八.标准上线流程

## 踩过得坑
1. 拿到原型图,理解业务逻辑
2. 根据逻辑设计数据库,表
3. 自己插入几个测试记录,编写SQL语句先验证一下逻辑理解的对不对
4. 翻看项目代码,或已有接口文档,参考JSON键名
5. 设计接口文档,JSON一定有设计好!!
6. 实现代码时不要全局置换!!少复制粘贴!!
7. 在RestController类里写接口对应的方法的业务逻辑时,必须用
```
try{ return new ZjyyResponse<>(ErrorCodeConstant.SUCCESS_CODE, "查询成功", model);
}catch (Exception e) {
            logger.error("查询修改历史出错", e);
            return new ZjyyResponse<>(ErrorCodeConstant.QUERY_ERROR_CODE, "查询失败");
        }
```
语句
```
ZjyyResponse(String code,String message,<T> data)
//这样写的好处
//data可以是任意形式
//如何把List<DimTagCateModel>信息放进Paginator<DimTagCateModel>里.
Paginator(, , , , , List<T> pageData)
//好处是pageData可以是任意List<XxModel>
```

## queryTagInfo接口心得
### 1.写好mapper.xml文件

### 2.实现了@Repository的DimTagHistoryMapper类
- 定义name_space
- 定义查询历史记录方法,传入long型tagId,返回List<DimTagHistooryDO>类的结果. 
- **DO类是传入数据库与传出数据库的前后端交互JSON的实体类**
- 定义插入历史记录的方法,传入DimTagHistoryDO,返回long型,大于0则插入成功,小于0则插入失败
![image](http://note.youdao.com/yws/res/9038/606924BB89D54A748C812F940ECB6A41)

### 3.Mapper类往上是实现了@Compent的DimTagManager类
- 基本上所有后台标签管理的页面操作都会写在这个类里

![image](http://note.youdao.com/yws/res/9060/50570E96E6414C76AEBE348A88FC1399)
### Manager类是manager层,处理具体的业务.
- 最关键的地方是将前端数据Query类,传到Mapper里参与数据库操作,返回List<DO>类数据实体
- 将List<DO>类实体传入DOs2Models()方法,返回List<Model>类数据实体
![image](http://note.youdao.com/yws/res/9064/4E4216B04589439EB46CD8FC701D839A)
**<center>中金易云代码架构--以分页查询标签为例</center>**
```
graph TB
前端--将web请求信息以JSON形式发给后端-->Query类实体
subgraph 在Manager类业务层里
    Query类实体-->Mapper类
    Mapper类--拿到Query里的前端数据-->调用Mapper_xml文件操作数据库
    Mapper类--返回-->DO数据库类实体
    DO数据库类实体--DO2Model转换-->给前端的Model类实体
    给前端的Model类实体-->Paginator类带分页信息
    Paginator类带分页信息-->传入ZjyyResponse类里格式化成JSON并序列化成Byte数组流
    传入ZjyyResponse类里格式化成JSON并序列化成Byte数组流--自动响应给-->前端
end
```
**<center>各种标注与跳转类</center>**
```
graph TB
subgraph 在Controller层定义接口名,请求方式,接收前端传来的JSON请求

    DimTagController注解RestController,DimTagServiceClient注解Service,DimTagService注解FeignClient,DimTagRestController注解RestController-->除了Client类不用显示定义接口名,只需定义RequestBody,其余三个类都要实现接口与接收参数
    除了Client类不用显示定义接口名,只需定义RequestBody,其余三个类都要实现接口与接收参数-->DimTagController与DimTagServiceClient在op端,DimTagService接口api与DimTagRestController实现类app都在bcs端
    DimTagMapper--被多用-->DimTagManager
    DimTagManager--被复用-->App层才是DimTagRestController
    App层才是DimTagRestController--实现-->Api层DimTagService
   RestController--具体实现-->DimTagService
   DimTagServiceClient--根据AutoWired注解自动new实体--> DimTagService
    通过实体service使用各种接口实现方法-->DimTagServiceClient
  RequestMapping具体实现类-->RestController
    RequestBody-->RequestMapping
    获取tagId等关键数据--对应Query类-->RequestBody
    最基本的异常处理--做非null判断-->获取tagId等关键数据
end
```
**<center>JSON请求体各级DOM对应的类</center>**
```
graph TB
    subgraph JSON最外层--Controller层--RestController
        最外层需要监视的异常-->code,message
        code,message--用get方法-->BizException
        ErrorCodeConstant--+手动输入message-->Exception
        DimTagCateModel-->ZjyyResponse
    end
    subgraph JSON data层--Manager层Component
        pageNo-->Paginator
        pageSize-->Paginator
        totalDataNum-->Paginator
        tatalPageNum-->Paginator
        data-->Paginator
    end
    subgraph JSON pageData层--Mapper层Repository
        List/DimTagCateModel/-->Data
        models-->Data
        pageNo-->data
        limit-->Data
        Data-->data
        totalDataNum-->data
    end
```
> 总结

    JSON树结构里,像pageData这样的容易List形式出现的节点.通常对应代码里,多用的,千变万化的Mapper层

![image](http://note.youdao.com/yws/res/9098/580A6599DA2143A0B6A25A2B1B00BC07)

### op服务DimTagController类导包详解
![image](http://note.youdao.com/yws/res/9154/A7949EABB9EE4CBAA74B0538A89E5858)

> Autowired 通过IOC注入,自动new对象
```
import DimTagService; //导入一个接口

public class DimTagServiceClient
    @Autowired
    private DimTagService service; //等价于 private DimTagService service = new DimTagServiceImpl();
    
    public void method(DimTagService tagService){
        //会自动使用DimTagControllerService的实现类创建实体tagControllerService
    }
```
> RestController
```
import DimTagControllerService; //导入一个接口
@RestController
public void method(DimTagControllerService tagControllerService){
    //会自动使用DimTagControllerService的实现类创建实体tagControllerService
}
```

```
  /**
     * 使用HttpServletRespinse自动响应
     * @see com.zjyy.bcs.api.service.dim.DimTagService#queryTagInfo(com.zjyy.bcs.api.model.dim.query.DimTagHistoryQuery)
     */
    @Override
    @RequestMapping(value = "/tag/queryTagInfo", method = RequestMethod.GET)
    public ZjyyResponse<List<DimTagHistoryModel>> queryTagInfo(@RequestBody DimTagHistoryQuery query, HttpServletResponse response) {
        try {
            if(query.getTagId()==null){
                return new ZjyyResponse<>(ErrorCodeConstant.QUERY_ERROR_CODE, "tagId不能为空");
            }
            List<DimTagHistoryModel> model = tagManager.queryHistoryById(query);
            return new ZjyyResponse<>(ErrorCodeConstant.SUCCESS_CODE, "查询成功", model);
            // response.getOutputStream().write(JSONObject.toJSONString(new ZjyyResponse<>(ErrorCodeConstant.SUCCESS_CODE, "查询成功", model)).getBytes());
        } catch (Exception e) {
            logger.error("查询修改历史出错", e);
            return new ZjyyResponse<>(ErrorCodeConstant.QUERY_ERROR_CODE, "查询失败");
        }
    }
```
```
graph LR
subgraph 项目组-汀池
袋鼠云--中金易云-->数据中台部
end
```

## 异常日志级别
```
trace-->debug
debug-->info
info-->warn
warn-->error
```

## 用API常量类替代路径的前缀与swagger注释
```
    String API_DISTR            = "/distr";
    String API_STORE            = "/store";
    String API_COMMON           = "/common";
    String HOME                 = "首页";
    String SALES_ANALYSIS       = "销售分析";
    String INTERBANK_ANALYSIS   = "同业分析";
    String INVENTORY            = "库存优化";
    String INVENTORY_BOOKLIST   = "库存优化-书单管理";
    String SETTING              = "设置";
```

## Indicators，FieldVO，FilterVO
```
更多指标，字段，筛选项下拉列表
```

 ```
 <!--修改-->
    <update id="updateStatus" parameterType="map">
        UPDATE
        <include refid="table_name"/>
        SET show_status = #{showStatus}, gmt_modified = now()
        WHERE tag_id = #{tagId}
    </update>
```

```
<!-- 查询 -->
    <select id="queryById" parameterType="java.lang.Long" resultMap="tagStatusMap">
        select
        <include refid="column_list"/>
        from
        <include refid="table_name"/>
        where tag_id = #{tagId}
    </select>
```

当远程部署出错时，先试下本地微服mvn务打包，再试下全项目打包，有问题去~/.m2/repository/里找,找不到再进入对应的细分服务下打包。全局打包报错看日志，很可能是下面的细分服务声明全局项目版本时，版本号错了的原因。


## 二期测试服务器
- 47.101.183.209
- root
- 9AAQ5jJjR8PB53JX
```
cd distr-app

/opt/maven/bin/mvn clean -U install -Pdev -DskipTests

cd ../

if ${is_all};then
	echo "==============全量打包==============="
    else
    	echo "==============仅打包业务包================="
        #解压
        mkdir distr-app/target/t
        tar -xzf distr-app/target/distr-app.tar.gz -C distr-app/target/t
        rm -f distr-app/target/distr-app.tar.gz
        #打包
        cd distr-app/target/t
        tar -czf ../distr-app.tar.gz lib/distr-*.jar
fi

```



- 地址 ssh root@47.100.111.124
- 密码 U7OuAuTcxHkxz@bb
- 目录 jenkins自动打包maven后会将项目部署在/app/下
- jps查看当前目录下的线程
- 进去/app/zjyy/zhyy-bcs-app/bin
- 看到logs,zjyy-bcs-app.sh
- ./zjyy-bcs-app.sh restart 重启服务
- cd logs,在less common.log查看启动日志
## 查看运行报错日志

- /home/admin/logs/zjyy-bussiness-core-service
- less common.log打开,shift+g跳至最后一行

## bcs部署服务器地址 
![image](http://note.youdao.com/yws/res/10288/822A2F99885E4DCEB1B4F58AF78F0792)
- 172.16.10.90 acb123 
- /var/lib/kenkins/workspace/zjyy-op


## distr-app 与 distr-bcs部署
- jenkins服务器在90，所有布90会方便点
- [jenkins-disr-app项目地址](http://172.16.10.90:8080/view/%E4%B8%AD%E9%87%91%E6%98%93%E4%BA%91/job/distr-app/configure)
```
工作区 /var/lib/kenkins/workspace/distr-app
1. 先进入../distr-bcs/api/ 打包 /opt/maven/bin/mvn clean -U install -Pdev -DskipTests 生成依赖jar包
2. 再进入../distr-app/ 打包 /opt/maven/bin/mvn clean -U install -Pdev -DskipTests 打包成功，后续都可以用kenkins快速部署
3. 上述任何一步失误，建议先在本地分别全局与各个微服务的app与api打包，排查下问题，再提交代码
```
- [jenkins-disr-app项目地址](http://172.16.10.90:8080/job/distr-bcs/configure)
```
同上
```