## 类

- 相同属性、方法、关系的对象的抽象。
- 封装了数据和行为。
- 封装、继承和多态
- Name,Attribute,Function

## 四种可见性 + - # ~

- public
- private
- protected
- friendly

<h5 style:text-align:center>经典UML类图</h5>


![](https://tva1.sinaimg.cn/large/006y8mN6ly1g84tfymubsj305u05zaa0.jpg)

## 接口
接口时特殊的类，只可以被子类实例化，只有空白方法，没有属性。
    
![](https://tva1.sinaimg.cn/large/006y8mN6ly1g84tjtk609j308c03r0sl.jpg)


## ClassDiagram
复杂类图

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g84tn1uiu4j30ku0b2weu.jpg)

## 类之间的关系

1 Dependency 虚线

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g84tob8l6lj30f0075mx9.jpg)

2 Association 棱形箭头

光联关系。多对多，A中有B的引用，B中有A的引用。  

 

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g84tqeg3kxj30go0443yl.jpg)

分三种，关联A用到B的引用。聚合，A里有大量B,C，D. 组合B,C,D组合成A,不可独立。

3 Generalization

继承 三角箭头

4 Realization

实现 虚线箭头


## 六大原则

    OCP，对拓展开放，对修改闭合。
 
接口定义规范，各种具体实现类，业务访问类里使用不同的实现类。
    
    LSP, 里氏替换

子类可以实现父类拓展，但不能改变父类原有功能。非要重写必须在子类里完全覆盖掉。

    DIP，依赖倒置。消费者换个消费对象时无须修改消费者的定义源码。消费者对象只需执行一次消费方法时改变一次实参。

面向接口编程，不面向实现编程。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

- 变量的声明类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生。
- 不要更改父类方法


    单一职责

以学生工作为例。

学生工作多而杂，全部交给学生工作者一种岗位很不合理。依据单一职责，可以拆成两大岗位。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g84vbqdekhj30ci0bzq3b.jpg)


    接口隔离

每个类需要什么功能就引用什么接口。不要搞一个很庞大的类把所有功能都塞里面。
太笨重了。

与单一职责共同规划了 业务 的颗粒度，即将不同的业务功能划分到不同的动作接口下。最经典的就是增删改查。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g84w501x90j30go0fmgm6.jpg)

    迪米特 ，LKP最少知道

只依赖要依赖的对象，最暴露应暴露的方法。通过向代理类传入参数，访问xx对象。


代码永远有四种类，生产者，代理者，消费者，餐馆（业务类）。比如明星，经纪人，粉丝或公司，Test类。

```java
// 合成复用
// 功能要细，能分就分，谁生产，谁消费，中间一定有个代理，全部在业务里执行。
public class LoDtest
{
    public static void main(String[] args)
    {
        Agent agent=new Agent();
        agent.setStar(new Star("林心如"));
        agent.setFans(new Fans("粉丝韩丞"));
        agent.setCompany(new Company("中国传媒有限公司"));
        agent.meeting();
        agent.business();
    }
}
```

    合成复用
    
- 不推荐继承复用，完全引用父类代码，父类变，子类也会变
- 而且是静态代码继承，编译阶段就定下了，不利于运行时拓展。
- 最好使用组合/聚合复用。大家凑一块，共同组成新的对象。

总结 ： 父对象的核心特点可以先继承再重构，一般特点分包出去再把它引用进来即可实现灵活组合。
![](https://tva1.sinaimg.cn/large/006y8mN6ly1g85jdct5ibj30iw09s3yr.jpg)

# 23种设计模式

    设计模式的精髓就是写好形参，最大程度利用实参，在不改动源码的情况下满足各类业务场景。
```java
// 已知String类名,生成类对象
{
    String cName="FactoryMethod."+classNode.getNodeValue();
    Class<?> c=Class.forName(cName);
    Object obj=c.newInstance();
}
```

```java
// 读取xml里面的配置，根据类名创建对象
import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.io.*;
class ReadXML
{
    public static Object getObject()
    {
        try
        {
            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();
            DocumentBuilder builder=dFactory.newDocumentBuilder();
            Document doc;                           
            doc=builder.parse(new File("src/AbstractFactory/config.xml"));
            NodeList nl=doc.getElementsByTagName("className");
            Node classNode=nl.item(0).getFirstChild();
            String cName="AbstractFactory."+classNode.getNodeValue();
            System.out.println("新类名："+cName);
            Class<?> c=Class.forName(cName);
              Object obj=c.newInstance();
            return obj;
        }  
        catch(Exception e)
        {
               e.printStackTrace();
               return null;
        }
    }
}
```
## 创建型模式


### 单例模式
    线程池 网络连接池 数据库连接池 web配置对象

节省资源，数据内容一致性，App开发常用。

懒汉式单例，时间换空间，每次不管三七二十一先判断一下instance创建了没有，很耽误性能。

```java
// volatile涉及到指令优化，防止创建对象时发生对象还未初始化，其引用就被分配了内存地址的情况发生，volatile常辅助`obj != null`使用。
public class LazySingleton
{
    private static volatile LazySingleton instance=null;    //保证 instance 在所有线程中同步
    private LazySingleton(){}    //private 避免类在外部被实例化
    // 使用synchronized虽然线程安全但是会发生同步阻塞，很耽误性能。
    // 保证从 if(instance==null) 到 return 这段语句一次只被一个线程执行，且必须执行完才能执行下一个线程。
    public static synchronized LazySingleton getInstance()
    {
        //getInstance 方法前加同步
        if(instance==null)
        {
            instance=new LazySingleton();
        }
        return instance;
    }
}
```

饿汉式单例，类一旦加载就创建一个静态的单例对象供系统调用，绝对多线程安全。
```java
public class HungrySingleton
{
    private static final HungrySingleton instance = new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance()
    {
        return instance;
    }
}
```

注意：XxxSingle.getInstance()一旦被执行过，下次再执行XxxSingle.getInstance()时还会执行一遍里面的内容，这时可以打点log，便于观察。

有限的多例（Multitcm）模式，实例间切换
![](https://tva1.sinaimg.cn/large/006y8mN6gy1g85m5vwfivj30h809vmxj.jpg)

```java

import java.util.ArrayList;
import java.util.Random;

public class Client {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		 int userNum=10;  
	        for(int i=0;i<userNum;i++){  
	            //用户获取到的连接时随机的  
	            SQLConnectionPools conn= SQLConnectionPools.getInstance();  
	            System.out.print("第"+i+"个用户获得的连接是：");  
	            conn.connectionInfo();  
	        }  
	}


public class SQLConnectionPools {
	private static int maxNumOfConnection= 8;
	private static ArrayList<String> connectionInfoList = new ArrayList<>(maxNumOfConnection);
	private static ArrayList<SQLConnectionPools> connArrayList = new ArrayList<>(maxNumOfConnection);
	private static int currNumOfConnection =0;
	
	private SQLConnectionPools() {
		// TODO Auto-generated constructor stub
	}
	
	private SQLConnectionPools(String info) {
		connectionInfoList.add(info);
	}
	
	static{
		for (int i = 0; i < maxNumOfConnection; i++) {
			connArrayList.add(new SQLConnectionPools(i+"号连接"));
		}
	}
	
	public static SQLConnectionPools getInstance() {
		Random random = new Random();
		currNumOfConnection = random.nextInt(maxNumOfConnection);
		return connArrayList.get(currNumOfConnection);
	}
	
	public void connectionInfo() {
		System.out.println(connectionInfoList.get(currNumOfConnection));
	}
	
}
```

### 原型复制模式

用于创建大量相同或相似的对象，又不适合使用多例模式时的场景。最简单的就是制定要创建的对象种类，`快速复制`，实现类里多一个clone方法。

```java
//具体原型类
class Realizetype implements Cloneable{
    Realizetype(){
        System.out.println("Protype was Created!");
    }

    public Object clone() throws CloneNotSupportedException {
        logger.info("Prototype is cloned!");
        return (Realizetype)super.clone();
    }
}
//原型模式的测试类
public class PrototypeTest
{
    public static void main(String[] args)throws CloneNotSupportedException
    {
        Realizetype obj1=new Realizetype();
        Realizetype obj2=(Realizetype)obj1.clone();
        // 浅克隆，输出为false
        System.out.println("obj1==obj2?"+(obj1==obj2)); 
    }
}
```

```java
public class ProtoTypeCitation
{
    public static void main(String[] args) throws CloneNotSupportedException
    {
        citation obj1=new citation("张三","同学：在2016学年第一学期中表现优秀，被评为三好学生。","韶关学院");
        obj1.display();
        citation obj2=(citation) obj1.clone();
        obj2.setName("李四"); 
        obj2.display();
    }
}
//奖状类
class citation implements Cloneable
{
    String name;
    String info;
    String college;
    citation(String name,String info,String college)
    {
        this.name=name;
        this.info=info;
        this.college=college;
        System.out.println("奖状创建成功！");
    }
    void setName(String name)
    {
        this.name=name;
    }
    String getName()
    {
        return(this.name);
    }
    void display()
    {
        System.out.println(name+info+college);
    }
    public Object clone() throws CloneNotSupportedException
    {
        System.out.println("奖状拷贝成功！");
        return (citation)super.clone();
    }
}
```


```java

import java.util.*;
interface Shape extends Cloneable
{
    public Object clone();    //拷贝
    public void countArea();    //计算面积
}

class Circle implements Shape
{
    public Object clone()
    {
        Circle w=null;
        try
        {
            w=(Circle)super.clone();
        }
        catch(CloneNotSupportedException e)
        {
            System.out.println("拷贝圆失败!");
        }
        return w;
    }
    public void countArea()
    {
        int r=0;
        System.out.print("这是一个圆，请输入圆的半径：");
        Scanner input=new Scanner(System.in);
        r=input.nextInt();
        System.out.println("该圆的面积="+3.1415*r*r+"\n");
    }
}

class Square implements Shape
{
    public Object clone()
    {
        Square b=null;
        try
        {
            b=(Square)super.clone();
        }
        catch(CloneNotSupportedException e)
        {
            System.out.println("拷贝正方形失败!");
        }
        return b;
    }
    public void countArea()
    {
        int a=0;
        System.out.print("这是一个正方形，请输入它的边长：");
        Scanner input=new Scanner(System.in);
        a=input.nextInt();
        System.out.println("该正方形的面积="+a*a+"\n");
    }
}

class ProtoTypeManager
{
    // 原型哈希表
    private HashMap<String, Shape> ht=new HashMap<String,Shape>(); 
    public ProtoTypeManager()
    {
        ht.put("Circle",new Circle());
           ht.put("Square",new Square());
    } 
    public void addshape(String key,Shape obj)
    {
        ht.put(key,obj);
    }

    // *利用浅拷贝的形式快速复制出一个对象
    public Shape getShape(String key)
    {
        Shape temp=ht.get(key);
        return (Shape) temp.clone();
    }
}

public class ProtoTypeShapeTest
{
    public static void main(String[] args)
    {
        ProtoTypeManager pm=new ProtoTypeManager();    
        Shape obj1=(Circle)pm.getShape("Circle");
        obj1.countArea();          
        Shape obj2=(Square)pm.getShape("Square");
        obj2.countArea();     
    }
}
```

### 工厂模式

    各种产品有专门的工厂生产

定义工厂接口，创建产品时使用接口，将生产过程推迟到具体工厂类。

经典的工厂模式有五大角色七个类，

Product
ConcreteProduct1
ConcreteProduct2

AbstractFactory
ConcreteFactory1
ConcreteFactory2

```java
package FactoryMethod;
public class AbstractFactoryTest
{
    public static void main(String[] args)
    {
        try
        {
            Product a;
            AbstractFactory af;
            af=(AbstractFactory) ReadXML1.getObject();
            a=af.newProduct();
            a.show();
        }
        catch(Exception e)
        {
            System.out.println(e.getMessage());
        }
    }
}
//抽象产品：提供了产品的接口
interface Product
{
    public void show();
}
//具体产品1：实现抽象产品中的抽象方法
class ConcreteProduct1 implements Product
{
    public void show()
    {
        System.out.println("具体产品1显示...");
    }
}
//具体产品2：实现抽象产品中的抽象方法
class ConcreteProduct2 implements Product
{
    public void show()
    {
        System.out.println("具体产品2显示...");
    }
}
//抽象工厂：提供了厂品的生成方法
interface AbstractFactory
{
    public Product newProduct();
}
// 或者
interface AnimalFarm
{
    public Animal newAnimal();
}

//具体工厂1：实现了厂品的生成方法
class ConcreteFactory1 implements AbstractFactory
{
    public Product newProduct()
    {
        System.out.println("具体工厂1生成-->具体产品1...");
        return new ConcreteProduct1();
    }
}
//具体工厂2：实现了厂品的生成方法
class ConcreteFactory2 implements AbstractFactory
{
    public Product newProduct()
    {
        System.out.println("具体工厂2生成-->具体产品2...");
        return new ConcreteProduct2();
    }
}
```

总结：工厂模式需要写死代码，有点蠢

## 抽象工厂模式

使用产品族概念，多个不同功能的产品组成一个产品族。

- 新增一个产品族时只需新增一个工厂即可。新增一个产品的话需要改动所有工厂，很麻烦，

## 建造者（Builder）模式

将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。
它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

各个具体的建造者相互独立，有利于系统的扩展。客户端不必知道产品内部组成的细节，便于控制细节风险。
工厂注重创建，建造者注重组装。


```java

// 产品角色：包含多个组成部件的复杂对象
class Product
{
    private String partA;
    private String partB;
    private String partC;
    public void setPartA(String partA)
    {
        this.partA=partA;
    }
    public void setPartB(String partB)
    {
        this.partB=partB;
    }
    public void setPartC(String partC)
    {
        this.partC=partC;
    }
    public void show()
    {
        //显示产品的特性
    }
}

// 抽象建造者：包含创建产品各个子部件的抽象方法。

abstract class Builder
{
    //创建产品对象
    protected Product product=new Product();
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
    //返回产品对象
    public Product getResult()
    {
        return product;
    }
}

// 具体建造者：实现了抽象建造者接口。
// 实现Builder里的abstract方法即可，不推荐 @Override
public class ConcreteBuilder extends Builder
{
    public void buildPartA()
    {
        product.setPartA("建造 PartA");
    }
    public void buildPartB()
    {
        product.setPartA("建造 PartB");
    }
    public void buildPartC()
    {
        product.setPartA("建造 PartC");
    }
}

// 指挥者：调用建造者中的方法完成复杂对象的创建。
class Director
{
    private Builder builder;
    public Director(Builder builder)
    {
        this.builder=builder;
    }
    //产品构建与组装方法
    public Product construct()
    {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getResult();
    }
}

public class BuildTest
{
    public static void main(String[] args)
    {
        // 发现构建的细节全部隐藏在construct方法内,Director只是一个组装平台（项目经理）
        // 或者ConcreteBuilder像图纸，Director是机器。机器吞了图纸后开始生产。
        //  如果只需一种产品，可以直接new XxxBuilder().construct()
        Product p = new Director(new ConcreteBuilder()).construct()
        p.show();
    }
}
```

## 结构型

    对象组合而成的一种复杂结构型模式  仅适配器模式有类结构模式


### 代理增强模式

    说是代理，其实就是在子类B里引用子类A的功能，并加以封装和增强，提供增值服务。

- 可拓展目标对象的功能，且松耦合
- 系统更复杂，请求处理更慢

```java
package proxy;
public class ProxyTest
{
    public static void main(String[] args)
    {
        new Proxy().Request();
    }
}
//抽象主题
interface Subject
{
    void Request();
}
//真实主题
class RealSubject implements Subject
{
    public void Request()
    {
        System.out.println("访问真实主题方法...");
    }
}
//代理
class Proxy implements Subject
{
    private RealSubject realSubject;
    public void Request()
    {
        if (realSubject==null)
        {
            realSubject=new RealSubject();
        }
        preRequest();
        realSubject.Request();
        postRequest();
    }
    // 前期增强，延迟，计数a对象的应用次数等
    public void preRequest()
    {
        System.out.println("访问真实主题之前的预处理。");
    }
    // 后期增强，回收a对象等
    public void postRequest()
    {
        System.out.println("访问真实主题之后的后续处理。");
    }
}


天天数码公司生产手机，京东商城卖手机。所以他们都要继承手机。
京东商城还会在贩卖手机的基础前，添加一些展示，加价方法。贩卖手机后执行售后服务方法。
客户只需通过京东商城就能享受一些列增值服务。
```

有时RealSubject太多了，代理类懒得一个个写进源码，可以用动态代理，method.invoke(obj,args[])     


## 适配器模式（Adapter）

    跟代理模式类似，比代理模式强得多，集成adaptee，实现target。
    代理是实现target，且被代理类也得实现target，非常限制。

将一个类的接口转换成客户希望的另外一个接口

本模式由Target目标接口，Adaptee待适配者，Adapter转换器三部分组成。

    

```java
//目标接口
interface Target
{
    public void request();
}
//适配者接口
class Adaptee
{
    public void specificRequest()
    {       
        System.out.println("适配者中的业务代码被调用！");
    }
}
//类适配器类
class ClassAdapter extends Adaptee implements Target
{
    public void request()
    {
        specificRequest();
    }
}
//客户端代码
public class ClassAdapterTest
{
    public static void main(String[] args)
    {
        System.out.println("类适配器模式测试：");
        Target target = new ClassAdapter();
        target.request();
    }
}
```

## Bridge桥接模式

    组合模式，告别继承，实现多维度排列组成新的类。
```java
public class BridgeTest
{
    public static void main(String[] args)
    {
        Implementor imple=new ConcreteImplementorA();
        Abstraction abs=new RefinedAbstraction(imple);
        abs.Operation();
    }
}
//实现化角色
interface Implementor
{
    public void OperationImpl();
}
//具体实现化角色
class ConcreteImplementorA implements Implementor
{
    public void OperationImpl()
    {
        System.out.println("具体实现化(Concrete Implementor)角色被访问" );
    }
}
//抽象化角色
abstract class Abstraction
{
   protected Implementor imple;
   protected Abstraction(Implementor imple)
   {
       this.imple=imple;
   }
   public abstract void Operation();   
}
//扩展抽象化角色
class RefinedAbstraction extends Abstraction
{
   protected RefinedAbstraction(Implementor imple)
   {
       super(imple);
   }

   public void Operation()
   {
       System.out.println("扩展抽象化(Refined Abstraction)角色被访问" );
       imple.OperationImpl();
   }
}
```

## 装饰模式
    告别继承，增强某对象的功能
通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。
    
    component concreteComponent decorator concreteDecorator

```java
package decorator;
public class DecoratorPattern
{
    public static void main(String[] args)
    {
        Component p=new ConcreteComponent();
        p.operation();
        System.out.println("---------------------------------");
        Component d=new ConcreteDecorator(p);
        d.operation();
    }
}
//四轮车
interface  Component
{
    public void operation();
}
//跑车
class ConcreteComponent implements Component
{
    public ConcreteComponent()
    {
        System.out.println("创建具体构件角色");       
    }   
    public void operation()
    {
        System.out.println("调用具体构件角色的方法operation()");           
    }
}
// 发动机车模板--可以装载其他型号的车，执行其他型号车的功能
class Decorator implements Component
{
    private Component component;   
    public Decorator(Component component)
    {
        this.component=component;
    }   
    public void operation()
    {
        component.operation();
    }
}
//10T涡轮发动机车
class ConcreteDecorator extends Decorator
{
    public ConcreteDecorator(Component component)
    {
        super(component);
    }   
    public void operation()
    {
        super.operation();
        addedFunction();
    }
    public void addedFunction()
    {
        System.out.println("为具体构件角色增加额外的功能addedFunction()");           
    }
}

```


## Facade外观模式

将所有子系统关联到一个外观类里，客户端只需访问外观类即可
![](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hl7lnowlj30ci0d8q38.jpg)
缺点是每增加一个子系统，就得修改外观类的源码，解决方案是引入抽象工厂设计模式，一个外类接口下实现多种不同的外观类，排列组合不同子系统的功能。

```java
public class FacadePattern
{
    public static void main(String[] args)
    {
        Facade f=new Facade();
        f.method();
    }
}
//外观角色
class Facade
{
    private SubSystem01 obj1=new SubSystem01();
    private SubSystem02 obj2=new SubSystem02();
    private SubSystem03 obj3=new SubSystem03();
    public void method()
    {
        obj1.method1();
        obj2.method2();
        obj3.method3();
    }
}
//子系统角色
class SubSystem01
{
    public  void method1()
    {
        System.out.println("子系统01的method1()被调用！");
    }   
}
//子系统角色
class SubSystem02
{
    public  void method2()
    {
        System.out.println("子系统02的method2()被调用！");
    }   
}
//子系统角色
class SubSystem03
{
    public  void method3()
    {
        System.out.println("子系统03的method3()被调用！");
    }   
}

```

## Flyweight享元模式

- Flyweight
- Concrete Flyweight
- Unsharable Flyweight
- Flyweight Factory
- TestFlyweight
```java


```

## 一段代码解释设计模式

    继承 ——△
    实现 --△
    依赖 -->
    组合 ——◇
    管理 ——>

单例模式
`SQLConnectionPools conn= SQLConnectionPools.getInstance(); `

原型模式
`Realizetype obj2=(Realizetype)(new Realizetype().clone());`

多原型模式
```java
Shape obj1=(Circle)new protoManager().getShape("Circle");
Shape obj2=(Square)new protoManager().getShape("Square");
```

工厂模式
```java
Product pr = (AbstractFactory) new XxxFactory().newProduct();
```

创建者模式
```java
Product --> partA,partB,partC;
interface Builder --> buildA,buildB,buildC;
ConcreteBuilder implements Builder;
Product p = new Director(new ConcreteBuilder()).construct()
```

代理模式
```java
Real implemetns Function;
Proxy implements Function contains newInstance(Real.class); 
new Proxy(ClassName).request```

适配器模式
```java
ClassAdapter extends Adaptee implements Target;
Target target = new ClassAdapter();
target.request();
```


桥接模式
    妙用多态,可搭配适配器,将可选的A配上可变的B,生成AB
```java
Implememtor imple = new ConcreteImplementorA();
// new 奔驰轿车(4缸发动机)
Abstraction abs = new RefinedAbstraction(imple)
```

装饰模式
    通过implements统一的接口+将a传入b的构造参数，实现了告别继承无子类封装，增强某对象的功能
    增强但不重构
```java
Component p=new ConcreteComponent();
p.operation();
// Decorator类无感知
Component d=new ConcreteDecorator(p);
d.operation();
```

外观模式
    多个子对象的功能关联到一个外观类的方法里，客户端只需调用一个外观对象的方法即可。
```java
Facade f=new Facade();
f.method();
```