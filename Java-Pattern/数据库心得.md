## 学习资源链接
> 致敬:[厦门大学数据库实验室][1]和CSDN作者[orangeliu][2]

> 特别感谢:[一步一步学MySQL系列][3]

[1]:http://dblab.xmu.edu.cn/post/architecture-of-a-database-system/
[2]:https://blog.csdn.net/orangleliu/article/details/54694272
[3]:https://blog.csdn.net/kkdd2013/article/list/2?t=1



### 背景介绍
> MySQL是the most popular ORM Database and the best Relational Database Management System(RDBMS)

Belong to Oracle

### Database
1. 数据表格形式
2. 每一行就是一个记录
3. 每一列就是一个数据域(参考枚举,本质就是一个column)
```
graph LR
rows-->table
columns-->table
table-->|tables|database
```
### RDBMS术语
1. 数据库:A set of related tables
2. 数据表:数据的二维矩阵
3. 列:attribute column 包含相同数据域的数据
4. 行:一行,一元组,一记录,A set of related data
5. 冗余:double data has been sorted
6. 主键:The primary key is always unique.A table can only contains one primary key at the same time
7. 外键:用于关联两张表
8. 复合键:类似于聚合,将多个column作为一个索引键
9. 索引:快速访问datatable中的特定信息,同时order by某列排序
10. 参照完整性:不允许引用不存在的实体与实体完整性(主键不可为null)配合
### MySQL介绍
1. 所谓关系数据库就是将不同的数据按抽象关系保存在不同的表中,而非全部存到一个大仓库中,增加了速度与灵活性
2. 64位系统MySQL支持8TB的表文件
3. 可根据GPL协议修改源码定制化自己的MySQL
4

## 获取字段的部分
```
MID(centName,6,2)
LEFT(centName,4) 
```
## MySQL基础
### 登入MySQL
连接MySQL服务:需要知道服务器主机名,你登入的用户名,密码(登入参数)
    
    mysql -h 127.0.0.1 -u root -p 
    分别表示需要登入的主机名 用户名 以密码901225登入

ctrl+D断开连接.
### 查看数据库
    show database
### 查看表
    show table
### 查看表结构
    desc table_name
### 查看引擎的线程
    SELECT trx_mysql_thread_id
 from information_schema.INNODB_TRX
kill 被锁的线程标号
### 查看列类型长
    select LENGTH(fieldname) from tablename
### 标准写法
    mysql> SELECT col_name FROM db_name.tbl_name;

### 文档常用写法
1. []表示可选
2. {}表示必选
3. | 表示多选一
4. [, ]表示可并列多写
## 基于Navicat for Mac 实操MySqL

### 支持函数与聚合查询
    mysql> SELECT CONCAT(first_name, ' ', last_name)
    -> FROM citizen
    -> WHERE income/dependents > 10000 AND age > 30;
### MySQL性能
    每表支持64条索引,每索引可包含16列,最大索引宽度1000Byte.



> 重要概念

    进入Navicat后,会要求连接到一个已有的服务器,可以连接多个.默认连接到mysql服务器.服务器内一个独立的database就是一个模式
> navicat快捷键
    
    cmd+o 打开table
    cmd+1 打开服务器目录
    cmd+2 打开table object ddl
    cmd++ 添加一行记录
    cmd+- 删除一行记录
    
    
### 经验
> 创建表
```
CREATE TABLE BOOKINFO (
ID bigint(20) NOT NULL AUTO_INCREMENT,
BOOKNAME VARCHAR(45),
PRIMARY KEY (`ID`)
) ENGINE=InnoDB AUTO_INCREMENT=10001 DEFAULT CHARSET=utf8
```
1. CREATE TABLE table_name()括号内最后一列column不可逗号结尾,必须直接挨着);
2. 如下图
![image](http://note.youdao.com/yws/res/2562/12CEC2C1FD5D4CB49CC76BE0664D9EF0)
3. cmd+2快速查看表的对象信息,包括ddl里的源码与注释
4. 如下图
![image](http://note.youdao.com/yws/res/2569/142A4EC5321945FA9AA87603203A2500)
5. 约束能保证数据库完整性,即不会出现错误数据.比如某个记录的PRIMARY_KEY居然是NULL
6. 
## 先修知识
    计算机安全
1. 保密性:权限分配
2. 在给定威胁模型下,设计不同的安全方案
3. 确定who are you what can you do
4. An easy way:you userId and password is week under forced attacked.


## SQL基础语句
    A database is formed by several related tables
## 1.什么是表
    A table is formed by columns critical and rows much more
## 2.什么是查询与修改
    An SQL query means DBMS how to filter and sort the useful data and confirm the key data you want
    
    An query also means how DBMS to alter a table or schema
*Holding on ahead ,if you happen to be familiar with SQL already.*

*I really hope you will be able to have a strong fundation for using SQL in your own project and beyond*

## 3.表结构
    Column seens like attribute as Table seens like Class,meanwhile,members of row we can always called instance

TABLE : Movies
Id | Title | Director | Year 
---|---|---|---
01 | Toy Story | John | 1995 
02 | Toy Story2 | John| 1997

TABLE : Boxoffice
Id | Local_sales | Inter_sales | Year 
---|---|---|---
01 | 35550001 | 43213123 | 1995 
02 | 54020312 | 56043312 | 1997

## 4.基础语法
    SQL大小写不敏感,但是为了区分SQL语句与内容,SQL指令统一大写
    查询的原理是依据SQL语句提取原表的内容重写生成一张副表,语句以分号结尾,一次查询只能用一次分号就够.

### 4.1 查询全体column
SELECT * FROM movies

### 4.2 查询01号电影的title,director
SELECT title,director FROM movies
WHERE id = 01

### 4.3 WHERE约束关系大全
- =,!=,<,> 匹配数字
- BETWEEN ... AND ... 匹配数字或字符范围
- =,!= 匹配字符串
- LIKE NOT LIKE 匹配正则字符串
- IS NULL,IS NOT NULL 匹配非空元素
- IN,NOT IN 匹配字符串列表 {"A","B","C"}


- WHERE后面只能跟一个column的约束关系,有时不够用
AND/OR 补充额外column的约束关系,最终定下集合
- SQL语句的字符串元素们必须用""引起,SQl语句无论是否字符串都不用"",避免二者混淆

### 4.4 "字符串"的通配符,
- "%AT%"可匹配"SAT","ATS","SATS","SSATSS"等
- "_AT"可匹配"SAT"等,必须有字符替代_

## 5.去重复 DISTINCT
    SELECT DISTINCT director FROM table
- DISTINCT column1,column2 则这两个属性为一组,两个属性完全相同才算重复,否则不丢弃
## 6.选中后排序
    //选中属性列并去重
    SELECT DISTINCT column1  
    //要操作的表
    FROM table
    //根据column2中满足条件的元素,选中整体表范围
    WHERE column2 like "John%"
        AND/OR
    //根据column3中元素的顺序对整个表作排序
    ORDER BY column3 ASC/DESC
    ASC 自然排序
    DESC 大数在前倒序
    //显示个数与初始位置,针对原始范围来说
    LIMIT 5 OFFSET 5 
    //向下偏移OFFSET不写,默认为偏移量为0
## 7.连接两张表
### 7.1 选中来自两张表的columns
    SELECT column1,column2 FROM table1
    //若非对称则保留右边的表的全部元素,左边匹配不上就丢弃
    RIGHT JOIN table2
    //匹配两表的主键与外键
        ON table1.key_column = table2.key_column
    //后续
    WHERE 
     AND/OR
    ORDER BY xxx ASC/DESC
    LIMIT x OFFSET y
```
graph LR
选中并去重-->B(确定非对称关系)
B-->C(两表主键匹配)
C-->D(约束范围)
D-->E(正反排序)
E-->F(控制显示)
```
```
graph LR
A(SELECT DISTINCT column1,cloumn2)-->|FROM table|B(INNER JOIN table2)
B-->C(ON table1.key_column = table2.key_column)
C-->D(WHERE colunm3 LIKE "")
D-->E(ORDER ON column4 ASC/DESC)
E-->F(LIMIT 5 OFFSET 5)
```
## 7.表达式
    SQL支持从现有属性里通过表达式算术计算生成新的属性
- SELECT (column1+column2)/1000 AS column3
- WHERE (column1+column2) < 1000
### 7.1 聚合表达(Compute聚合计算)
    提取出需要的元素并创建为新的属性
- COUNT(column1) AS column_count //属性内元素个数
- MAX(column1) AS column_max //属性内元素的最大值
- AVG(column1) AS column_avg //属性内元素的平均自
- SUM(column1) AS column_sum //属性内元素的总和
## 8.分组聚合
    GROUP BY column1 整张表都会根据column1里相同的元素划分到同一组
    HAVING column2 LIKE "" 每组再根据HAVING的约束关系选定范围
- GROUP一旦分组,SQL语句会分别对每组起作用,如最大,最小,平均,总和,个数
- 故GROUP不是DISTINCT,DISTINCT是横向分组,且组内都相同才算重复
- GROUP是column内相同的为一组
## 9.表结构 列们有哪些值
    表结构,就是表的每一列可以包含的DATATYPE
### 9.1 行操作
    删除行
- DELETE FROM table WHERE column LIKE ""
    
    
    添加行 默认加到最后一行
- INSERT INTO table
(column1,column2,,,)
VALUES (1,9.9,2831/100)
    

    更改行
- UPDATE table SET(column1 = x,column2 = xx) WHERE
- UPDATE table SET column1 = x WHERE
- 若无WHERE则自动更改全部行

## 10.表模式
    创建表,定义表模式,有哪些列
    即每列的列名,数据结构,约束关系,DEFAULT值
### 10.1 创建表
    CREATE TABLE table( column DataType TableConstrait DEFAULT values, another_column,)
### 10.2 列的约束类别(键级别)
    PRIMARY KEY :主键
    FOREIGN KEY :外键
    AUTOINCREMENT :自动填充并递增
    UNIQUE:唯一,不可重复
    NOT NULL:不可为NULL
    CHECK(表达式): 一个列先天性的范围约束或特点前缀\
### 10.3 DataType类别
```
graph LR
    String-->TEXT
    int-->INTEGER
    float-->FLOAT
    char-->CHARACTER
    chars-->VARCHAR 
```
    修改表ALTER TABLE table
- INSERT INTO table只能添加一行,不能算修改表模式,更不能修改表关系
- ALTER TABLE 会修改表模式
    - 对表增 ALTER TABLE table add column datatype
    - 对表删 ALTER TABLE table DROP column 因为必须选定column对象,所以不必担心把整张表都删了
    - 重命名 ALTER TABLE table RENAME TO new_table_name
## 阶段总结
    For each Database has its own set of features and optimizations

## SQL Server详解
    创建数据库
```SQL
create database mrkj
on // 定义主文件
(name = mrdat,
filename = 'G:\sql\mrkj.mdf',
size = 10,
maxsize = 100,
filegrowth = 5)
log on //定义日志文件
(name = mrlog,
filename = 'G:\sql\mrlog.ldf',
size = 8mb,
maxsize = 50mb,
filegrowth = 8mb)
```
### 修改数据库
    将mrkj添加到MinRi数据库中
```SQL
ALTER DATABASE MingRi
ADD FILE
(
NAME = mrkj
filename = 'G:\mrkj.ndf',
size = 10MB,
maxsize = 100MB,
filegrowth = 2MB
)
```
    使用指令(存储过程)sp_renamedb修改数据库名
```sql
exec sp_renamedb 'mr','mrsoft'
```
### 删除数据库
    系统db不可删,每次删完必须立即更新master
```
不可删正在运行的,
use db_student
drop database db_student
报错,请在别的数据库里删除db_student
use db_2018
go
drop database db_student
```
## 创建表
    用户自定义数据类型,供创建表与添加列时使用
```SQL
use db_sharp
//创建自定义数据类型
exec sp_addtype postcode,'char(8)','not null'
//删除数据类型
exec sp_droptype postcode
```
    完整性 主键为not null

### 创建视图
    把行操作或表操作修改过的表,用view以副表形式呈现出来
```
在正常的sql语句前加
USE db_2018
GO
CREATE VIEW view1
AS
SELECT ,,,
```
```
通过视图删除
use db_2018
go
drop view v1
go
通过视图删除数据
use db_2018
go
delete v1
where name = "zhang"
select * from v1
go
```

### 嵌套查询 WHERE语句的拓展
> 若column2只在table2里,可以简写成嵌套查询
    
    SELECT column1,column2 FROM table1
    RIGHT JOIN table2
        ON table1.key_column = table2.key_column
    WHERE column2 > 90
  

> 若column2即在table1里,也在table2里,可以简写成关联查询
    
    SELECT column1 FROM table1
    WHERE column2=(SELECT column2 FROM table2 WHERE column2 > 90)
> 
    RIGHT JOIN的简写
    SELECT * FROM table1
    WHERE column2 IN(SELECT column2 FROM table2)
> 
    AVG(age) AS some 的简写
    SELECT * FROM student
    WHERE age < SOME
    (SELECT AVG(age) FROM student)
> 
    UNION 将两表中根据同名column取得的列,合并到一起,以副表形式生成
    默认UNION DISTINCT,有需要时可用UNION ALL
    
    
## 视图
- 视图不占存储空间,只是一个副表,不可有排序,计算插入操作
- 水平视图取行:creat view v1 as select * from table where (id = '0903')
- 投影视图取列:
- 创建联合视图
## 索引
- 索引是DB对象之一.为了加速对表中数据行的检索而创建的一种分散的存储结构.即加速检索记录
- 在表外针对性建立一张针对该表的索引页面
```sql
create unique clustered index book_id_index
on book(book_id asc)
with
fillfactor = 50
```
## 存储过程
预先编译好的,存在sql server服务器上与特色DB向关联的SQL代码集合
- 可以重复使用,减少我们的工作量
- 提高性能,提前编译好了,直接用
- 可以防止SQL注入,建议Grant,Deny,Revoke,权限在存储过程里使用
```sql
create proc spAAStudents
as
begin transaction
insert into . .students
value @name

if 
begin
rollback 

commit transaction
```

建立一个学生选课管理数据库。
表：学生表、班级表、教师表、课程表、学生选课表。
逻辑关系：每个学生有一个班级；每个班级对应一个班主任教师；每个教师只能当一个班的班主任
```
CREATE DATABASE stu_mangaer
USE stu_manager;

CREATE TABLE stu_tbl
(
    ID VARCHAR(255) PRIMARY KEY,
    NAME VARCHAR(10) NOT NULL,
    SEX VARCHAR(10),
    BIRTHDAY DADTE,
    CLASS_ID VARCHAR(255)
)

INSERT INTO STU_TBL
(ID,NAME,SEX,BIRTHDAY,CLASS_ID)
VALUES('121','HUANG','男',1995-07-18,'201320090109')


/* 建立数据库 */  
CREATE DATABASE STUDENT_MANAGER;  
USE STUDENT_MANAGER;  
  
/***** 建立student表 *****/
CREATE TABLE STUDENT_TBL  
(  
   STUDENT_ID         VARCHAR(255) PRIMARY KEY,  
   STUDENT_NAME       VARCHAR(10) NOT NULL,  
   STUDENT_SEX        VARCHAR(10),  
   STUDENT_BIRTHDAY   DATE,  
   CLASS_ID           VARCHAR(255)  
);  


  
/*插入学生数据*/  
INSERT INTO STUDENT_TBL (STUDENT_ID,  
                         STUDENT_NAME,  
                         STUDENT_SEX,  
                         STUDENT_BIRTHDAY,  
                         CLASS_ID)  
  VALUES   (123456,  
            '某某某',  
            '女',  
            '1980-08-01',  
            121546  
            )  
            
```

**找出最晚入职的员工的所有信息**
```sql
SELECT * FROM employees
WHERE hire_date = (SELECT max(hire_date) FROM employees)
```
可见 SELECT max(hire_date) FROM employees 本身就是一个表达式,等价于一个hire_date数据

**找出倒数第三晚的员工**
```sql
SELECT * FROM employees
ORDER BY hire_date DESC
LIMIT 2,1;
```
LIMIT 2,1表示先向下偏移2个元素,即从第三个元素开始显示,只显示一个元素.
## 事务

> insert,update,delete 操作的数据量大时,需要用到事务transaction
    
    原子性atomicity,一致性consistence,隔离性isolation,持久性durability
- A:所有操作要么全部完成,要么回滚到事务前
- C:保证DB的完整性,输入的类型要对,数据要合理,不能有null的地方一定不能null,比如key
- I:
- 

## MySQL设计规范从源头规范
1. 安全用户名:用户名+特许IP
2. 一次一万条以下.超过则分批
3. 同一业务同一库,禁止夸库操作
4. 业务计算尽量在应用层.
5. 读多写少则做读写分离innodb

库,表,字段 12字符以内.用"_"分割,尽量名词

1. 表必有主键,且是自增的有序id.避免innodb插入数据时重排列.
2. 存高精度数时用DECIMAL.禁用DOUBLE,有损失
3. UNSIGNED存储非负数 INT UNSIGNED存IPV4
4. 存短数据0-80时用TINYINT
5. 不要存储TEXT,BLOB类型的大文件,mysql不适合
6. VARCHAR(N),N是字符数,不是字节
7. UTF8,GBK
8. VARBINARY存储变长字段
9. TIMESTAMP 4字节存储时间,DATESTAMP 8字节
10. 所有字段必须NOT NULL.设默认值
    
    索引规范
1. 多列组成索引
2. 非唯一索引:idx_col1_col2
3. 唯一索引:unique_col1_col2
4. 没有唯一键:要么自增,要么int
5. 索引字段的顺序.去重后,元素更多的字段放前面
6. VARCHAR类型字段过长时,添加MD% Hash字段,并对Hash建立索引.
7. 利用联合索引避免冗余
8. 利用覆盖索引.不需要回到主表.

    SQL规范
1. 避免SQL注入:prepared statement
2. IN不要包含过多,否则容易引发全局扫描
3. WHERE 数字与字符比较时,MySQL会做隐式转换
4. INSERT INTO table_name VALUES()
5. 避免三表JOIN查询
6. 避免ORDER BY RAND()
7. 统计使用记录COUNT(*)
8. 不建议前匹配查询 "%abc"
9. 禁止在增删改中做关联操作,结果将不可控

    分库分表
1. 单表>1000万个记录 或 10G
2. 单实例下多个表总和超过500G
3. 字段必须有索引
4. 
# 专业MySQL知识
#### SELECT
> 从表选中数据存于一个结果集(副表)中
    
    select * from table_name
#### SELECT DISTINCT
> 取单列时用于去重

- 取多列时会把多列合成一个组合去重
- 不支持取多列的同时只对其中某列去重
- 因为SQL无法判断未去重的其他列改取哪些记录
#### WHERE
> WHERE子句过滤 where operate value
- value为int无须引号,为varchar需加单引号
- 优先级: () not and or
    
    where 1=1 
    and cent_id not in ('10001','10002','1003')
    and not cent_book_id > 1500
    and comm is null
    and id between 1500 and 3000 (闭区间)
    and id in (5000,1000,100)
    and cent_name like '%浙江_' (浙江后面一定有且只有一个字)
    
# SQL优化策略
MySQL以BTree作索引存储，故索引宜用MyIsam做引，增删改事务较多可用InnoDB引擎（支持Transcation），用EXPLAIN分析SQL性能
- select，in，from，exists选中的是一个集合（多列或单列或只有一个元素的列）
- = like 选中的是一个元素
#### count优化
> 只要查询过一次，MySQL就会自动获取表的总行数

所以
    
    select (select count(*) from world.city) – count(*) from world.city where id <= 5
是优于

    select count(*) from world.city where id > 5
最快

    select count(*) from world.city
    
#### 最小化结果集
    尽量减少访问的行数，分开多次操作，索引必须首先select，
#### 字段不要加函数操作
    where f/2 = 100 改造成 where f = 200
#### in is null都会使索引失效
    多使用exists或not exists
#### 多用数字型字段
    数字类型只需比较一次，varchar类型InnoDB引擎会逐一比较每个字符
#### 合理使用exists
    
    SELECT SUM(T1.C1) FROM T1 WHERE EXISTS(SELECT * FROM T2 WHERE T2.C2=T1.C2)
优于
    
    SELECT SUM(T1.C1) FROM T1 WHERE (SELECT COUNT(*) FROM T2 WHERE T2.C2=T1.C2) > 0)     
exists会自动检索有没有某行记录

    IF EXISTS (SELECT * FROM table_name WHERE column_name = ‘xxx’)
优于
    IF (SELECT COUNT(*) FROM table_name WHERE column_name = ‘xxx’)
    
#### 常规优化
- 能between就不要用in
- 能distinct就不要group by
- 拒绝select into，会锁表导致其他用户无法访问
- 强制使用索引：SELECT * FROM T1 (INDEX = IX_ProcessID) WHERE nextprocess = 1 AND processid IN (8,32,45) 则查询优化器将会强行利用索引IX_ProcessID 执行查询
#### 并查and or 导致索引失效
    SELECT * FROM orders WHERE customer_num=104 AND order_num>1001 UNION SELECT * FROM orders WHERE order_num=1008
- 优于


    SELECT * FROM orders WHERE (customer_num=104 AND order_num>1001) OR order_num=1008
#### %号优化
'L%'效率远高与'%L%'

#### update
    避免update wehere子句中的列
#### 字段数据优化
    创建时尽量not null default 0
####
    select film.film_id, film.description from sakila.film inner join(select film_id from sakila.film order by title liimit 50,5) as film usinig(film_id) 使用索引

#### 大表优化

    zjyy-bcs/zjyy-bcs-app/src/main/resources/mapper/op/masterdata/dim_cent_pay_mapping-mapper.xml
    
#### 索引优化
    索引应打在where，order by 的子句列上

## MySQL必知必会
### 关键概念
1. database
2. table
3. row or record 
4. column 每一列都应该是一种单独的抽象,拥有与其他抽象旗帜鲜明不同的特点
5. datatype 根据抽象描述的不同,采用对应的数据类型,极大方便列排序,存储优化与存储正确
6. primary key 单个或多个列成组,能够唯一标识表中某行记录的概念.能够确保SQL操作不会涉及到特定行以外.主键最好是ID,用字符做主键可能存在改来改去的风险.
7. not null
8. SQL structed query language
9. schema 包含数据库表的布局与特性信息,即schema = database + table
### 关键功能
1. 数据库引擎
2. 事务处理
## 登录
1. mysql -h 127.0.0.1 -u root -p
2. SHOW databases
3. use database
4. SHOW tables
5. SHOW columns from table || field,datatype
## 4 select
    select prod_name from product
是按存储顺序显示数据,顺序不可预测.
    select * from product
各列按列在表模式中的顺序依次出现,shcema变化如列增减都会导致结果集变化
    select distinct author_id,prod_id from product
distinct只能作用在所有列前,以多个列为一组筛不同.
    select prod_name from product limit 5
向下位移0后,取5个数据
    select prod_name from product limit 5,10
行5开始的
    
